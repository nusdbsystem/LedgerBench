// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: strong-proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_strong_2dproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_strong_2dproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common-proto.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_strong_2dproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_strong_2dproto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_strong_2dproto_2eproto;
namespace strongstore {
namespace proto {
class AbortMessage;
class AbortMessageDefaultTypeInternal;
extern AbortMessageDefaultTypeInternal _AbortMessage_default_instance_;
class AuditMessage;
class AuditMessageDefaultTypeInternal;
extern AuditMessageDefaultTypeInternal _AuditMessage_default_instance_;
class BatchGetMessage;
class BatchGetMessageDefaultTypeInternal;
extern BatchGetMessageDefaultTypeInternal _BatchGetMessage_default_instance_;
class CommitMessage;
class CommitMessageDefaultTypeInternal;
extern CommitMessageDefaultTypeInternal _CommitMessage_default_instance_;
class GetMessage;
class GetMessageDefaultTypeInternal;
extern GetMessageDefaultTypeInternal _GetMessage_default_instance_;
class LedgerDBProof;
class LedgerDBProofDefaultTypeInternal;
extern LedgerDBProofDefaultTypeInternal _LedgerDBProof_default_instance_;
class MPTProof;
class MPTProofDefaultTypeInternal;
extern MPTProofDefaultTypeInternal _MPTProof_default_instance_;
class MTProof;
class MTProofDefaultTypeInternal;
extern MTProofDefaultTypeInternal _MTProof_default_instance_;
class PrepareMessage;
class PrepareMessageDefaultTypeInternal;
extern PrepareMessageDefaultTypeInternal _PrepareMessage_default_instance_;
class QLDBProof;
class QLDBProofDefaultTypeInternal;
extern QLDBProofDefaultTypeInternal _QLDBProof_default_instance_;
class Range;
class RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class RangeMessage;
class RangeMessageDefaultTypeInternal;
extern RangeMessageDefaultTypeInternal _RangeMessage_default_instance_;
class Reply;
class ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class Reply_Digest;
class Reply_DigestDefaultTypeInternal;
extern Reply_DigestDefaultTypeInternal _Reply_Digest_default_instance_;
class Reply_KV;
class Reply_KVDefaultTypeInternal;
extern Reply_KVDefaultTypeInternal _Reply_KV_default_instance_;
class Reply_LedgerDBAudit;
class Reply_LedgerDBAuditDefaultTypeInternal;
extern Reply_LedgerDBAuditDefaultTypeInternal _Reply_LedgerDBAudit_default_instance_;
class Reply_SQLLedgerAudit;
class Reply_SQLLedgerAuditDefaultTypeInternal;
extern Reply_SQLLedgerAuditDefaultTypeInternal _Reply_SQLLedgerAudit_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SQLLedgerProof;
class SQLLedgerProofDefaultTypeInternal;
extern SQLLedgerProofDefaultTypeInternal _SQLLedgerProof_default_instance_;
class USTOREProof;
class USTOREProofDefaultTypeInternal;
extern USTOREProofDefaultTypeInternal _USTOREProof_default_instance_;
class VerifyMessage;
class VerifyMessageDefaultTypeInternal;
extern VerifyMessageDefaultTypeInternal _VerifyMessage_default_instance_;
class VersionMessage;
class VersionMessageDefaultTypeInternal;
extern VersionMessageDefaultTypeInternal _VersionMessage_default_instance_;
class VersionMessage_VersionedKey;
class VersionMessage_VersionedKeyDefaultTypeInternal;
extern VersionMessage_VersionedKeyDefaultTypeInternal _VersionMessage_VersionedKey_default_instance_;
}  // namespace proto
}  // namespace strongstore
PROTOBUF_NAMESPACE_OPEN
template<> ::strongstore::proto::AbortMessage* Arena::CreateMaybeMessage<::strongstore::proto::AbortMessage>(Arena*);
template<> ::strongstore::proto::AuditMessage* Arena::CreateMaybeMessage<::strongstore::proto::AuditMessage>(Arena*);
template<> ::strongstore::proto::BatchGetMessage* Arena::CreateMaybeMessage<::strongstore::proto::BatchGetMessage>(Arena*);
template<> ::strongstore::proto::CommitMessage* Arena::CreateMaybeMessage<::strongstore::proto::CommitMessage>(Arena*);
template<> ::strongstore::proto::GetMessage* Arena::CreateMaybeMessage<::strongstore::proto::GetMessage>(Arena*);
template<> ::strongstore::proto::LedgerDBProof* Arena::CreateMaybeMessage<::strongstore::proto::LedgerDBProof>(Arena*);
template<> ::strongstore::proto::MPTProof* Arena::CreateMaybeMessage<::strongstore::proto::MPTProof>(Arena*);
template<> ::strongstore::proto::MTProof* Arena::CreateMaybeMessage<::strongstore::proto::MTProof>(Arena*);
template<> ::strongstore::proto::PrepareMessage* Arena::CreateMaybeMessage<::strongstore::proto::PrepareMessage>(Arena*);
template<> ::strongstore::proto::QLDBProof* Arena::CreateMaybeMessage<::strongstore::proto::QLDBProof>(Arena*);
template<> ::strongstore::proto::Range* Arena::CreateMaybeMessage<::strongstore::proto::Range>(Arena*);
template<> ::strongstore::proto::RangeMessage* Arena::CreateMaybeMessage<::strongstore::proto::RangeMessage>(Arena*);
template<> ::strongstore::proto::Reply* Arena::CreateMaybeMessage<::strongstore::proto::Reply>(Arena*);
template<> ::strongstore::proto::Reply_Digest* Arena::CreateMaybeMessage<::strongstore::proto::Reply_Digest>(Arena*);
template<> ::strongstore::proto::Reply_KV* Arena::CreateMaybeMessage<::strongstore::proto::Reply_KV>(Arena*);
template<> ::strongstore::proto::Reply_LedgerDBAudit* Arena::CreateMaybeMessage<::strongstore::proto::Reply_LedgerDBAudit>(Arena*);
template<> ::strongstore::proto::Reply_SQLLedgerAudit* Arena::CreateMaybeMessage<::strongstore::proto::Reply_SQLLedgerAudit>(Arena*);
template<> ::strongstore::proto::Request* Arena::CreateMaybeMessage<::strongstore::proto::Request>(Arena*);
template<> ::strongstore::proto::SQLLedgerProof* Arena::CreateMaybeMessage<::strongstore::proto::SQLLedgerProof>(Arena*);
template<> ::strongstore::proto::USTOREProof* Arena::CreateMaybeMessage<::strongstore::proto::USTOREProof>(Arena*);
template<> ::strongstore::proto::VerifyMessage* Arena::CreateMaybeMessage<::strongstore::proto::VerifyMessage>(Arena*);
template<> ::strongstore::proto::VersionMessage* Arena::CreateMaybeMessage<::strongstore::proto::VersionMessage>(Arena*);
template<> ::strongstore::proto::VersionMessage_VersionedKey* Arena::CreateMaybeMessage<::strongstore::proto::VersionMessage_VersionedKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace strongstore {
namespace proto {

enum Request_Operation : int {
  Request_Operation_GET = 1,
  Request_Operation_PREPARE = 2,
  Request_Operation_COMMIT = 3,
  Request_Operation_ABORT = 4,
  Request_Operation_VERIFY_GET = 5,
  Request_Operation_RANGE = 6,
  Request_Operation_BATCH_GET = 7,
  Request_Operation_AUDIT = 8
};
bool Request_Operation_IsValid(int value);
constexpr Request_Operation Request_Operation_Operation_MIN = Request_Operation_GET;
constexpr Request_Operation Request_Operation_Operation_MAX = Request_Operation_AUDIT;
constexpr int Request_Operation_Operation_ARRAYSIZE = Request_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_Operation_descriptor();
template<typename T>
inline const std::string& Request_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_Operation_descriptor(), enum_t_value);
}
inline bool Request_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_Operation>(
    Request_Operation_descriptor(), name, value);
}
// ===================================================================

class GetMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.GetMessage) */ {
 public:
  inline GetMessage() : GetMessage(nullptr) {}
  virtual ~GetMessage();

  GetMessage(const GetMessage& from);
  GetMessage(GetMessage&& from) noexcept
    : GetMessage() {
    *this = ::std::move(from);
  }

  inline GetMessage& operator=(const GetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMessage& operator=(GetMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMessage* internal_default_instance() {
    return reinterpret_cast<const GetMessage*>(
               &_GetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetMessage& a, GetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMessage* New() const final {
    return CreateMaybeMessage<GetMessage>(nullptr);
  }

  GetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMessage& from);
  void MergeFrom(const GetMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.GetMessage";
  }
  protected:
  explicit GetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .TimestampMessage timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::TimestampMessage& timestamp() const;
  ::TimestampMessage* release_timestamp();
  ::TimestampMessage* mutable_timestamp();
  void set_allocated_timestamp(::TimestampMessage* timestamp);
  private:
  const ::TimestampMessage& _internal_timestamp() const;
  ::TimestampMessage* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::TimestampMessage* timestamp);
  ::TimestampMessage* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:strongstore.proto.GetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::TimestampMessage* timestamp_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class PrepareMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.PrepareMessage) */ {
 public:
  inline PrepareMessage() : PrepareMessage(nullptr) {}
  virtual ~PrepareMessage();

  PrepareMessage(const PrepareMessage& from);
  PrepareMessage(PrepareMessage&& from) noexcept
    : PrepareMessage() {
    *this = ::std::move(from);
  }

  inline PrepareMessage& operator=(const PrepareMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareMessage& operator=(PrepareMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrepareMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareMessage* internal_default_instance() {
    return reinterpret_cast<const PrepareMessage*>(
               &_PrepareMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PrepareMessage& a, PrepareMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrepareMessage* New() const final {
    return CreateMaybeMessage<PrepareMessage>(nullptr);
  }

  PrepareMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrepareMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrepareMessage& from);
  void MergeFrom(const PrepareMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.PrepareMessage";
  }
  protected:
  explicit PrepareMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // required .TransactionMessage txn = 1;
  bool has_txn() const;
  private:
  bool _internal_has_txn() const;
  public:
  void clear_txn();
  const ::TransactionMessage& txn() const;
  ::TransactionMessage* release_txn();
  ::TransactionMessage* mutable_txn();
  void set_allocated_txn(::TransactionMessage* txn);
  private:
  const ::TransactionMessage& _internal_txn() const;
  ::TransactionMessage* _internal_mutable_txn();
  public:
  void unsafe_arena_set_allocated_txn(
      ::TransactionMessage* txn);
  ::TransactionMessage* unsafe_arena_release_txn();

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.PrepareMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TransactionMessage* txn_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class CommitMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.CommitMessage) */ {
 public:
  inline CommitMessage() : CommitMessage(nullptr) {}
  virtual ~CommitMessage();

  CommitMessage(const CommitMessage& from);
  CommitMessage(CommitMessage&& from) noexcept
    : CommitMessage() {
    *this = ::std::move(from);
  }

  inline CommitMessage& operator=(const CommitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitMessage& operator=(CommitMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommitMessage* internal_default_instance() {
    return reinterpret_cast<const CommitMessage*>(
               &_CommitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CommitMessage& a, CommitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommitMessage* New() const final {
    return CreateMaybeMessage<CommitMessage>(nullptr);
  }

  CommitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommitMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommitMessage& from);
  void MergeFrom(const CommitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.CommitMessage";
  }
  protected:
  explicit CommitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.CommitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class AbortMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.AbortMessage) */ {
 public:
  inline AbortMessage() : AbortMessage(nullptr) {}
  virtual ~AbortMessage();

  AbortMessage(const AbortMessage& from);
  AbortMessage(AbortMessage&& from) noexcept
    : AbortMessage() {
    *this = ::std::move(from);
  }

  inline AbortMessage& operator=(const AbortMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortMessage& operator=(AbortMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbortMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbortMessage* internal_default_instance() {
    return reinterpret_cast<const AbortMessage*>(
               &_AbortMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AbortMessage& a, AbortMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbortMessage* New() const final {
    return CreateMaybeMessage<AbortMessage>(nullptr);
  }

  AbortMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbortMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbortMessage& from);
  void MergeFrom(const AbortMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbortMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.AbortMessage";
  }
  protected:
  explicit AbortMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnFieldNumber = 1,
  };
  // required .TransactionMessage txn = 1;
  bool has_txn() const;
  private:
  bool _internal_has_txn() const;
  public:
  void clear_txn();
  const ::TransactionMessage& txn() const;
  ::TransactionMessage* release_txn();
  ::TransactionMessage* mutable_txn();
  void set_allocated_txn(::TransactionMessage* txn);
  private:
  const ::TransactionMessage& _internal_txn() const;
  ::TransactionMessage* _internal_mutable_txn();
  public:
  void unsafe_arena_set_allocated_txn(
      ::TransactionMessage* txn);
  ::TransactionMessage* unsafe_arena_release_txn();

  // @@protoc_insertion_point(class_scope:strongstore.proto.AbortMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TransactionMessage* txn_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class VerifyMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.VerifyMessage) */ {
 public:
  inline VerifyMessage() : VerifyMessage(nullptr) {}
  virtual ~VerifyMessage();

  VerifyMessage(const VerifyMessage& from);
  VerifyMessage(VerifyMessage&& from) noexcept
    : VerifyMessage() {
    *this = ::std::move(from);
  }

  inline VerifyMessage& operator=(const VerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyMessage& operator=(VerifyMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VerifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyMessage* internal_default_instance() {
    return reinterpret_cast<const VerifyMessage*>(
               &_VerifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VerifyMessage& a, VerifyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VerifyMessage* New() const final {
    return CreateMaybeMessage<VerifyMessage>(nullptr);
  }

  VerifyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VerifyMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VerifyMessage& from);
  void MergeFrom(const VerifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.VerifyMessage";
  }
  protected:
  explicit VerifyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kBlockFieldNumber = 1,
  };
  // repeated bytes keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // optional int64 block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  ::PROTOBUF_NAMESPACE_ID::int64 block() const;
  void set_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_block() const;
  void _internal_set_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.VerifyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::int64 block_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class AuditMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.AuditMessage) */ {
 public:
  inline AuditMessage() : AuditMessage(nullptr) {}
  virtual ~AuditMessage();

  AuditMessage(const AuditMessage& from);
  AuditMessage(AuditMessage&& from) noexcept
    : AuditMessage() {
    *this = ::std::move(from);
  }

  inline AuditMessage& operator=(const AuditMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuditMessage& operator=(AuditMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AuditMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuditMessage* internal_default_instance() {
    return reinterpret_cast<const AuditMessage*>(
               &_AuditMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AuditMessage& a, AuditMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuditMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuditMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuditMessage* New() const final {
    return CreateMaybeMessage<AuditMessage>(nullptr);
  }

  AuditMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuditMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AuditMessage& from);
  void MergeFrom(const AuditMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuditMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.AuditMessage";
  }
  protected:
  explicit AuditMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
  };
  // optional int64 seq = 1;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::int64 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.AuditMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 seq_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class VersionMessage_VersionedKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.VersionMessage.VersionedKey) */ {
 public:
  inline VersionMessage_VersionedKey() : VersionMessage_VersionedKey(nullptr) {}
  virtual ~VersionMessage_VersionedKey();

  VersionMessage_VersionedKey(const VersionMessage_VersionedKey& from);
  VersionMessage_VersionedKey(VersionMessage_VersionedKey&& from) noexcept
    : VersionMessage_VersionedKey() {
    *this = ::std::move(from);
  }

  inline VersionMessage_VersionedKey& operator=(const VersionMessage_VersionedKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionMessage_VersionedKey& operator=(VersionMessage_VersionedKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionMessage_VersionedKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionMessage_VersionedKey* internal_default_instance() {
    return reinterpret_cast<const VersionMessage_VersionedKey*>(
               &_VersionMessage_VersionedKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VersionMessage_VersionedKey& a, VersionMessage_VersionedKey& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionMessage_VersionedKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionMessage_VersionedKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionMessage_VersionedKey* New() const final {
    return CreateMaybeMessage<VersionMessage_VersionedKey>(nullptr);
  }

  VersionMessage_VersionedKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionMessage_VersionedKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionMessage_VersionedKey& from);
  void MergeFrom(const VersionMessage_VersionedKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionMessage_VersionedKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.VersionMessage.VersionedKey";
  }
  protected:
  explicit VersionMessage_VersionedKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kNversionsFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional int32 nversions = 2;
  bool has_nversions() const;
  private:
  bool _internal_has_nversions() const;
  public:
  void clear_nversions();
  ::PROTOBUF_NAMESPACE_ID::int32 nversions() const;
  void set_nversions(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nversions() const;
  void _internal_set_nversions(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.VersionMessage.VersionedKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::int32 nversions_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class VersionMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.VersionMessage) */ {
 public:
  inline VersionMessage() : VersionMessage(nullptr) {}
  virtual ~VersionMessage();

  VersionMessage(const VersionMessage& from);
  VersionMessage(VersionMessage&& from) noexcept
    : VersionMessage() {
    *this = ::std::move(from);
  }

  inline VersionMessage& operator=(const VersionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionMessage& operator=(VersionMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionMessage* internal_default_instance() {
    return reinterpret_cast<const VersionMessage*>(
               &_VersionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VersionMessage& a, VersionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionMessage* New() const final {
    return CreateMaybeMessage<VersionMessage>(nullptr);
  }

  VersionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionMessage& from);
  void MergeFrom(const VersionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.VersionMessage";
  }
  protected:
  explicit VersionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VersionMessage_VersionedKey VersionedKey;

  // accessors -------------------------------------------------------

  enum : int {
    kVersionedKeysFieldNumber = 1,
  };
  // repeated .strongstore.proto.VersionMessage.VersionedKey versionedKeys = 1;
  int versionedkeys_size() const;
  private:
  int _internal_versionedkeys_size() const;
  public:
  void clear_versionedkeys();
  ::strongstore::proto::VersionMessage_VersionedKey* mutable_versionedkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::VersionMessage_VersionedKey >*
      mutable_versionedkeys();
  private:
  const ::strongstore::proto::VersionMessage_VersionedKey& _internal_versionedkeys(int index) const;
  ::strongstore::proto::VersionMessage_VersionedKey* _internal_add_versionedkeys();
  public:
  const ::strongstore::proto::VersionMessage_VersionedKey& versionedkeys(int index) const;
  ::strongstore::proto::VersionMessage_VersionedKey* add_versionedkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::VersionMessage_VersionedKey >&
      versionedkeys() const;

  // @@protoc_insertion_point(class_scope:strongstore.proto.VersionMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::VersionMessage_VersionedKey > versionedkeys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class RangeMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.RangeMessage) */ {
 public:
  inline RangeMessage() : RangeMessage(nullptr) {}
  virtual ~RangeMessage();

  RangeMessage(const RangeMessage& from);
  RangeMessage(RangeMessage&& from) noexcept
    : RangeMessage() {
    *this = ::std::move(from);
  }

  inline RangeMessage& operator=(const RangeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeMessage& operator=(RangeMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RangeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeMessage* internal_default_instance() {
    return reinterpret_cast<const RangeMessage*>(
               &_RangeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RangeMessage& a, RangeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RangeMessage* New() const final {
    return CreateMaybeMessage<RangeMessage>(nullptr);
  }

  RangeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RangeMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RangeMessage& from);
  void MergeFrom(const RangeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.RangeMessage";
  }
  protected:
  explicit RangeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // optional string from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  void set_from(const std::string& value);
  void set_from(std::string&& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  std::string* mutable_from();
  std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const std::string& to() const;
  void set_to(const std::string& value);
  void set_to(std::string&& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  std::string* mutable_to();
  std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.RangeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class BatchGetMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.BatchGetMessage) */ {
 public:
  inline BatchGetMessage() : BatchGetMessage(nullptr) {}
  virtual ~BatchGetMessage();

  BatchGetMessage(const BatchGetMessage& from);
  BatchGetMessage(BatchGetMessage&& from) noexcept
    : BatchGetMessage() {
    *this = ::std::move(from);
  }

  inline BatchGetMessage& operator=(const BatchGetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchGetMessage& operator=(BatchGetMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BatchGetMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchGetMessage* internal_default_instance() {
    return reinterpret_cast<const BatchGetMessage*>(
               &_BatchGetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BatchGetMessage& a, BatchGetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchGetMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchGetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchGetMessage* New() const final {
    return CreateMaybeMessage<BatchGetMessage>(nullptr);
  }

  BatchGetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchGetMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchGetMessage& from);
  void MergeFrom(const BatchGetMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.BatchGetMessage";
  }
  protected:
  explicit BatchGetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // optional .TimestampMessage timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::TimestampMessage& timestamp() const;
  ::TimestampMessage* release_timestamp();
  ::TimestampMessage* mutable_timestamp();
  void set_allocated_timestamp(::TimestampMessage* timestamp);
  private:
  const ::TimestampMessage& _internal_timestamp() const;
  ::TimestampMessage* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::TimestampMessage* timestamp);
  ::TimestampMessage* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:strongstore.proto.BatchGetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::TimestampMessage* timestamp_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Request_Operation Operation;
  static constexpr Operation GET =
    Request_Operation_GET;
  static constexpr Operation PREPARE =
    Request_Operation_PREPARE;
  static constexpr Operation COMMIT =
    Request_Operation_COMMIT;
  static constexpr Operation ABORT =
    Request_Operation_ABORT;
  static constexpr Operation VERIFY_GET =
    Request_Operation_VERIFY_GET;
  static constexpr Operation RANGE =
    Request_Operation_RANGE;
  static constexpr Operation BATCH_GET =
    Request_Operation_BATCH_GET;
  static constexpr Operation AUDIT =
    Request_Operation_AUDIT;
  static inline bool Operation_IsValid(int value) {
    return Request_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    Request_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    Request_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    Request_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return Request_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return Request_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return Request_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGetFieldNumber = 3,
    kPrepareFieldNumber = 4,
    kCommitFieldNumber = 5,
    kAbortFieldNumber = 6,
    kVerifyFieldNumber = 7,
    kVersionFieldNumber = 8,
    kRangeFieldNumber = 10,
    kBatchgetFieldNumber = 11,
    kAuditFieldNumber = 12,
    kTxnidFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // optional .strongstore.proto.GetMessage get = 3;
  bool has_get() const;
  private:
  bool _internal_has_get() const;
  public:
  void clear_get();
  const ::strongstore::proto::GetMessage& get() const;
  ::strongstore::proto::GetMessage* release_get();
  ::strongstore::proto::GetMessage* mutable_get();
  void set_allocated_get(::strongstore::proto::GetMessage* get);
  private:
  const ::strongstore::proto::GetMessage& _internal_get() const;
  ::strongstore::proto::GetMessage* _internal_mutable_get();
  public:
  void unsafe_arena_set_allocated_get(
      ::strongstore::proto::GetMessage* get);
  ::strongstore::proto::GetMessage* unsafe_arena_release_get();

  // optional .strongstore.proto.PrepareMessage prepare = 4;
  bool has_prepare() const;
  private:
  bool _internal_has_prepare() const;
  public:
  void clear_prepare();
  const ::strongstore::proto::PrepareMessage& prepare() const;
  ::strongstore::proto::PrepareMessage* release_prepare();
  ::strongstore::proto::PrepareMessage* mutable_prepare();
  void set_allocated_prepare(::strongstore::proto::PrepareMessage* prepare);
  private:
  const ::strongstore::proto::PrepareMessage& _internal_prepare() const;
  ::strongstore::proto::PrepareMessage* _internal_mutable_prepare();
  public:
  void unsafe_arena_set_allocated_prepare(
      ::strongstore::proto::PrepareMessage* prepare);
  ::strongstore::proto::PrepareMessage* unsafe_arena_release_prepare();

  // optional .strongstore.proto.CommitMessage commit = 5;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::strongstore::proto::CommitMessage& commit() const;
  ::strongstore::proto::CommitMessage* release_commit();
  ::strongstore::proto::CommitMessage* mutable_commit();
  void set_allocated_commit(::strongstore::proto::CommitMessage* commit);
  private:
  const ::strongstore::proto::CommitMessage& _internal_commit() const;
  ::strongstore::proto::CommitMessage* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::strongstore::proto::CommitMessage* commit);
  ::strongstore::proto::CommitMessage* unsafe_arena_release_commit();

  // optional .strongstore.proto.AbortMessage abort = 6;
  bool has_abort() const;
  private:
  bool _internal_has_abort() const;
  public:
  void clear_abort();
  const ::strongstore::proto::AbortMessage& abort() const;
  ::strongstore::proto::AbortMessage* release_abort();
  ::strongstore::proto::AbortMessage* mutable_abort();
  void set_allocated_abort(::strongstore::proto::AbortMessage* abort);
  private:
  const ::strongstore::proto::AbortMessage& _internal_abort() const;
  ::strongstore::proto::AbortMessage* _internal_mutable_abort();
  public:
  void unsafe_arena_set_allocated_abort(
      ::strongstore::proto::AbortMessage* abort);
  ::strongstore::proto::AbortMessage* unsafe_arena_release_abort();

  // optional .strongstore.proto.VerifyMessage verify = 7;
  bool has_verify() const;
  private:
  bool _internal_has_verify() const;
  public:
  void clear_verify();
  const ::strongstore::proto::VerifyMessage& verify() const;
  ::strongstore::proto::VerifyMessage* release_verify();
  ::strongstore::proto::VerifyMessage* mutable_verify();
  void set_allocated_verify(::strongstore::proto::VerifyMessage* verify);
  private:
  const ::strongstore::proto::VerifyMessage& _internal_verify() const;
  ::strongstore::proto::VerifyMessage* _internal_mutable_verify();
  public:
  void unsafe_arena_set_allocated_verify(
      ::strongstore::proto::VerifyMessage* verify);
  ::strongstore::proto::VerifyMessage* unsafe_arena_release_verify();

  // optional .strongstore.proto.VersionMessage version = 8;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::strongstore::proto::VersionMessage& version() const;
  ::strongstore::proto::VersionMessage* release_version();
  ::strongstore::proto::VersionMessage* mutable_version();
  void set_allocated_version(::strongstore::proto::VersionMessage* version);
  private:
  const ::strongstore::proto::VersionMessage& _internal_version() const;
  ::strongstore::proto::VersionMessage* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::strongstore::proto::VersionMessage* version);
  ::strongstore::proto::VersionMessage* unsafe_arena_release_version();

  // optional .strongstore.proto.RangeMessage range = 10;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::strongstore::proto::RangeMessage& range() const;
  ::strongstore::proto::RangeMessage* release_range();
  ::strongstore::proto::RangeMessage* mutable_range();
  void set_allocated_range(::strongstore::proto::RangeMessage* range);
  private:
  const ::strongstore::proto::RangeMessage& _internal_range() const;
  ::strongstore::proto::RangeMessage* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::strongstore::proto::RangeMessage* range);
  ::strongstore::proto::RangeMessage* unsafe_arena_release_range();

  // optional .strongstore.proto.BatchGetMessage batchget = 11;
  bool has_batchget() const;
  private:
  bool _internal_has_batchget() const;
  public:
  void clear_batchget();
  const ::strongstore::proto::BatchGetMessage& batchget() const;
  ::strongstore::proto::BatchGetMessage* release_batchget();
  ::strongstore::proto::BatchGetMessage* mutable_batchget();
  void set_allocated_batchget(::strongstore::proto::BatchGetMessage* batchget);
  private:
  const ::strongstore::proto::BatchGetMessage& _internal_batchget() const;
  ::strongstore::proto::BatchGetMessage* _internal_mutable_batchget();
  public:
  void unsafe_arena_set_allocated_batchget(
      ::strongstore::proto::BatchGetMessage* batchget);
  ::strongstore::proto::BatchGetMessage* unsafe_arena_release_batchget();

  // optional .strongstore.proto.AuditMessage audit = 12;
  bool has_audit() const;
  private:
  bool _internal_has_audit() const;
  public:
  void clear_audit();
  const ::strongstore::proto::AuditMessage& audit() const;
  ::strongstore::proto::AuditMessage* release_audit();
  ::strongstore::proto::AuditMessage* mutable_audit();
  void set_allocated_audit(::strongstore::proto::AuditMessage* audit);
  private:
  const ::strongstore::proto::AuditMessage& _internal_audit() const;
  ::strongstore::proto::AuditMessage* _internal_mutable_audit();
  public:
  void unsafe_arena_set_allocated_audit(
      ::strongstore::proto::AuditMessage* audit);
  ::strongstore::proto::AuditMessage* unsafe_arena_release_audit();

  // required uint64 txnid = 2;
  bool has_txnid() const;
  private:
  bool _internal_has_txnid() const;
  public:
  void clear_txnid();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid() const;
  void set_txnid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid() const;
  void _internal_set_txnid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .strongstore.proto.Request.Operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::strongstore::proto::Request_Operation op() const;
  void set_op(::strongstore::proto::Request_Operation value);
  private:
  ::strongstore::proto::Request_Operation _internal_op() const;
  void _internal_set_op(::strongstore::proto::Request_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Request)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::strongstore::proto::GetMessage* get_;
  ::strongstore::proto::PrepareMessage* prepare_;
  ::strongstore::proto::CommitMessage* commit_;
  ::strongstore::proto::AbortMessage* abort_;
  ::strongstore::proto::VerifyMessage* verify_;
  ::strongstore::proto::VersionMessage* version_;
  ::strongstore::proto::RangeMessage* range_;
  ::strongstore::proto::BatchGetMessage* batchget_;
  ::strongstore::proto::AuditMessage* audit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_;
  int op_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class LedgerDBProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.LedgerDBProof) */ {
 public:
  inline LedgerDBProof() : LedgerDBProof(nullptr) {}
  virtual ~LedgerDBProof();

  LedgerDBProof(const LedgerDBProof& from);
  LedgerDBProof(LedgerDBProof&& from) noexcept
    : LedgerDBProof() {
    *this = ::std::move(from);
  }

  inline LedgerDBProof& operator=(const LedgerDBProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline LedgerDBProof& operator=(LedgerDBProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LedgerDBProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerDBProof* internal_default_instance() {
    return reinterpret_cast<const LedgerDBProof*>(
               &_LedgerDBProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LedgerDBProof& a, LedgerDBProof& b) {
    a.Swap(&b);
  }
  inline void Swap(LedgerDBProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LedgerDBProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LedgerDBProof* New() const final {
    return CreateMaybeMessage<LedgerDBProof>(nullptr);
  }

  LedgerDBProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LedgerDBProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LedgerDBProof& from);
  void MergeFrom(const LedgerDBProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerDBProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.LedgerDBProof";
  }
  protected:
  explicit LedgerDBProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 3,
    kMtPosFieldNumber = 4,
    kMptChunksFieldNumber = 6,
    kMptPosFieldNumber = 7,
    kValFieldNumber = 1,
    kHashFieldNumber = 2,
    kMptvalueFieldNumber = 5,
  };
  // repeated bytes proof = 3;
  int proof_size() const;
  private:
  int _internal_proof_size() const;
  public:
  void clear_proof();
  const std::string& proof(int index) const;
  std::string* mutable_proof(int index);
  void set_proof(int index, const std::string& value);
  void set_proof(int index, std::string&& value);
  void set_proof(int index, const char* value);
  void set_proof(int index, const void* value, size_t size);
  std::string* add_proof();
  void add_proof(const std::string& value);
  void add_proof(std::string&& value);
  void add_proof(const char* value);
  void add_proof(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proof() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proof();
  private:
  const std::string& _internal_proof(int index) const;
  std::string* _internal_add_proof();
  public:

  // repeated int32 mt_pos = 4;
  int mt_pos_size() const;
  private:
  int _internal_mt_pos_size() const;
  public:
  void clear_mt_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mt_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_mt_pos() const;
  void _internal_add_mt_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_mt_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 mt_pos(int index) const;
  void set_mt_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_mt_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      mt_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_mt_pos();

  // repeated bytes mpt_chunks = 6;
  int mpt_chunks_size() const;
  private:
  int _internal_mpt_chunks_size() const;
  public:
  void clear_mpt_chunks();
  const std::string& mpt_chunks(int index) const;
  std::string* mutable_mpt_chunks(int index);
  void set_mpt_chunks(int index, const std::string& value);
  void set_mpt_chunks(int index, std::string&& value);
  void set_mpt_chunks(int index, const char* value);
  void set_mpt_chunks(int index, const void* value, size_t size);
  std::string* add_mpt_chunks();
  void add_mpt_chunks(const std::string& value);
  void add_mpt_chunks(std::string&& value);
  void add_mpt_chunks(const char* value);
  void add_mpt_chunks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mpt_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mpt_chunks();
  private:
  const std::string& _internal_mpt_chunks(int index) const;
  std::string* _internal_add_mpt_chunks();
  public:

  // repeated int32 mpt_pos = 7;
  int mpt_pos_size() const;
  private:
  int _internal_mpt_pos_size() const;
  public:
  void clear_mpt_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mpt_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_mpt_pos() const;
  void _internal_add_mpt_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_mpt_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 mpt_pos(int index) const;
  void set_mpt_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_mpt_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      mpt_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_mpt_pos();

  // optional bytes val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  void set_val(const std::string& value);
  void set_val(std::string&& value);
  void set_val(const char* value);
  void set_val(const void* value, size_t size);
  std::string* mutable_val();
  std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // optional bytes hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional bytes mptvalue = 5;
  bool has_mptvalue() const;
  private:
  bool _internal_has_mptvalue() const;
  public:
  void clear_mptvalue();
  const std::string& mptvalue() const;
  void set_mptvalue(const std::string& value);
  void set_mptvalue(std::string&& value);
  void set_mptvalue(const char* value);
  void set_mptvalue(const void* value, size_t size);
  std::string* mutable_mptvalue();
  std::string* release_mptvalue();
  void set_allocated_mptvalue(std::string* mptvalue);
  private:
  const std::string& _internal_mptvalue() const;
  void _internal_set_mptvalue(const std::string& value);
  std::string* _internal_mutable_mptvalue();
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.LedgerDBProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proof_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > mt_pos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mpt_chunks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > mpt_pos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mptvalue_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class QLDBProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.QLDBProof) */ {
 public:
  inline QLDBProof() : QLDBProof(nullptr) {}
  virtual ~QLDBProof();

  QLDBProof(const QLDBProof& from);
  QLDBProof(QLDBProof&& from) noexcept
    : QLDBProof() {
    *this = ::std::move(from);
  }

  inline QLDBProof& operator=(const QLDBProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline QLDBProof& operator=(QLDBProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QLDBProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QLDBProof* internal_default_instance() {
    return reinterpret_cast<const QLDBProof*>(
               &_QLDBProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QLDBProof& a, QLDBProof& b) {
    a.Swap(&b);
  }
  inline void Swap(QLDBProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QLDBProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QLDBProof* New() const final {
    return CreateMaybeMessage<QLDBProof>(nullptr);
  }

  QLDBProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QLDBProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QLDBProof& from);
  void MergeFrom(const QLDBProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QLDBProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.QLDBProof";
  }
  protected:
  explicit QLDBProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 7,
    kPosFieldNumber = 8,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kBlocknoFieldNumber = 3,
    kDocSeqFieldNumber = 4,
    kVersionFieldNumber = 5,
    kTimeFieldNumber = 6,
  };
  // repeated bytes hashes = 7;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // repeated int32 pos = 8;
  int pos_size() const;
  private:
  int _internal_pos_size() const;
  public:
  void clear_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_pos() const;
  void _internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 pos(int index) const;
  void set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_pos();

  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional uint64 blockno = 3;
  bool has_blockno() const;
  private:
  bool _internal_has_blockno() const;
  public:
  void clear_blockno();
  ::PROTOBUF_NAMESPACE_ID::uint64 blockno() const;
  void set_blockno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blockno() const;
  void _internal_set_blockno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 doc_seq = 4;
  bool has_doc_seq() const;
  private:
  bool _internal_has_doc_seq() const;
  public:
  void clear_doc_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 doc_seq() const;
  void set_doc_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_doc_seq() const;
  void _internal_set_doc_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 time = 6;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.QLDBProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > pos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blockno_;
  ::PROTOBUF_NAMESPACE_ID::uint64 doc_seq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class MTProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.MTProof) */ {
 public:
  inline MTProof() : MTProof(nullptr) {}
  virtual ~MTProof();

  MTProof(const MTProof& from);
  MTProof(MTProof&& from) noexcept
    : MTProof() {
    *this = ::std::move(from);
  }

  inline MTProof& operator=(const MTProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline MTProof& operator=(MTProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MTProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MTProof* internal_default_instance() {
    return reinterpret_cast<const MTProof*>(
               &_MTProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MTProof& a, MTProof& b) {
    a.Swap(&b);
  }
  inline void Swap(MTProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MTProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MTProof* New() const final {
    return CreateMaybeMessage<MTProof>(nullptr);
  }

  MTProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MTProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MTProof& from);
  void MergeFrom(const MTProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MTProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.MTProof";
  }
  protected:
  explicit MTProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 3,
    kPosFieldNumber = 4,
    kDigestFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated bytes proof = 3;
  int proof_size() const;
  private:
  int _internal_proof_size() const;
  public:
  void clear_proof();
  const std::string& proof(int index) const;
  std::string* mutable_proof(int index);
  void set_proof(int index, const std::string& value);
  void set_proof(int index, std::string&& value);
  void set_proof(int index, const char* value);
  void set_proof(int index, const void* value, size_t size);
  std::string* add_proof();
  void add_proof(const std::string& value);
  void add_proof(std::string&& value);
  void add_proof(const char* value);
  void add_proof(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proof() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proof();
  private:
  const std::string& _internal_proof(int index) const;
  std::string* _internal_add_proof();
  public:

  // repeated int32 pos = 4;
  int pos_size() const;
  private:
  int _internal_pos_size() const;
  public:
  void clear_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_pos() const;
  void _internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 pos(int index) const;
  void set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_pos();

  // optional bytes digest = 1;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  void set_digest(const std::string& value);
  void set_digest(std::string&& value);
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  std::string* mutable_digest();
  std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional bytes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.MTProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proof_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > pos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class MPTProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.MPTProof) */ {
 public:
  inline MPTProof() : MPTProof(nullptr) {}
  virtual ~MPTProof();

  MPTProof(const MPTProof& from);
  MPTProof(MPTProof&& from) noexcept
    : MPTProof() {
    *this = ::std::move(from);
  }

  inline MPTProof& operator=(const MPTProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline MPTProof& operator=(MPTProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MPTProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MPTProof* internal_default_instance() {
    return reinterpret_cast<const MPTProof*>(
               &_MPTProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MPTProof& a, MPTProof& b) {
    a.Swap(&b);
  }
  inline void Swap(MPTProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MPTProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MPTProof* New() const final {
    return CreateMaybeMessage<MPTProof>(nullptr);
  }

  MPTProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MPTProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MPTProof& from);
  void MergeFrom(const MPTProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MPTProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.MPTProof";
  }
  protected:
  explicit MPTProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunksFieldNumber = 2,
    kPosFieldNumber = 3,
    kValueFieldNumber = 1,
  };
  // repeated bytes chunks = 2;
  int chunks_size() const;
  private:
  int _internal_chunks_size() const;
  public:
  void clear_chunks();
  const std::string& chunks(int index) const;
  std::string* mutable_chunks(int index);
  void set_chunks(int index, const std::string& value);
  void set_chunks(int index, std::string&& value);
  void set_chunks(int index, const char* value);
  void set_chunks(int index, const void* value, size_t size);
  std::string* add_chunks();
  void add_chunks(const std::string& value);
  void add_chunks(std::string&& value);
  void add_chunks(const char* value);
  void add_chunks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_chunks();
  private:
  const std::string& _internal_chunks(int index) const;
  std::string* _internal_add_chunks();
  public:

  // repeated int32 pos = 3;
  int pos_size() const;
  private:
  int _internal_pos_size() const;
  public:
  void clear_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_pos() const;
  void _internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 pos(int index) const;
  void set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_pos();

  // optional bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.MPTProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> chunks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > pos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class SQLLedgerProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.SQLLedgerProof) */ {
 public:
  inline SQLLedgerProof() : SQLLedgerProof(nullptr) {}
  virtual ~SQLLedgerProof();

  SQLLedgerProof(const SQLLedgerProof& from);
  SQLLedgerProof(SQLLedgerProof&& from) noexcept
    : SQLLedgerProof() {
    *this = ::std::move(from);
  }

  inline SQLLedgerProof& operator=(const SQLLedgerProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline SQLLedgerProof& operator=(SQLLedgerProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SQLLedgerProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SQLLedgerProof* internal_default_instance() {
    return reinterpret_cast<const SQLLedgerProof*>(
               &_SQLLedgerProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SQLLedgerProof& a, SQLLedgerProof& b) {
    a.Swap(&b);
  }
  inline void Swap(SQLLedgerProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SQLLedgerProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SQLLedgerProof* New() const final {
    return CreateMaybeMessage<SQLLedgerProof>(nullptr);
  }

  SQLLedgerProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SQLLedgerProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SQLLedgerProof& from);
  void MergeFrom(const SQLLedgerProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SQLLedgerProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.SQLLedgerProof";
  }
  protected:
  explicit SQLLedgerProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 3,
    kDigestFieldNumber = 4,
    kBlkProofFieldNumber = 1,
    kTxnProofFieldNumber = 2,
  };
  // repeated bytes blocks = 3;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  const std::string& blocks(int index) const;
  std::string* mutable_blocks(int index);
  void set_blocks(int index, const std::string& value);
  void set_blocks(int index, std::string&& value);
  void set_blocks(int index, const char* value);
  void set_blocks(int index, const void* value, size_t size);
  std::string* add_blocks();
  void add_blocks(const std::string& value);
  void add_blocks(std::string&& value);
  void add_blocks(const char* value);
  void add_blocks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blocks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blocks();
  private:
  const std::string& _internal_blocks(int index) const;
  std::string* _internal_add_blocks();
  public:

  // optional bytes digest = 4;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  void set_digest(const std::string& value);
  void set_digest(std::string&& value);
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  std::string* mutable_digest();
  std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional .strongstore.proto.MTProof blk_proof = 1;
  bool has_blk_proof() const;
  private:
  bool _internal_has_blk_proof() const;
  public:
  void clear_blk_proof();
  const ::strongstore::proto::MTProof& blk_proof() const;
  ::strongstore::proto::MTProof* release_blk_proof();
  ::strongstore::proto::MTProof* mutable_blk_proof();
  void set_allocated_blk_proof(::strongstore::proto::MTProof* blk_proof);
  private:
  const ::strongstore::proto::MTProof& _internal_blk_proof() const;
  ::strongstore::proto::MTProof* _internal_mutable_blk_proof();
  public:
  void unsafe_arena_set_allocated_blk_proof(
      ::strongstore::proto::MTProof* blk_proof);
  ::strongstore::proto::MTProof* unsafe_arena_release_blk_proof();

  // optional .strongstore.proto.MTProof txn_proof = 2;
  bool has_txn_proof() const;
  private:
  bool _internal_has_txn_proof() const;
  public:
  void clear_txn_proof();
  const ::strongstore::proto::MTProof& txn_proof() const;
  ::strongstore::proto::MTProof* release_txn_proof();
  ::strongstore::proto::MTProof* mutable_txn_proof();
  void set_allocated_txn_proof(::strongstore::proto::MTProof* txn_proof);
  private:
  const ::strongstore::proto::MTProof& _internal_txn_proof() const;
  ::strongstore::proto::MTProof* _internal_mutable_txn_proof();
  public:
  void unsafe_arena_set_allocated_txn_proof(
      ::strongstore::proto::MTProof* txn_proof);
  ::strongstore::proto::MTProof* unsafe_arena_release_txn_proof();

  // @@protoc_insertion_point(class_scope:strongstore.proto.SQLLedgerProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::strongstore::proto::MTProof* blk_proof_;
  ::strongstore::proto::MTProof* txn_proof_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Range PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  virtual ~Range();

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Range* New() const final {
    return CreateMaybeMessage<Range>(nullptr);
  }

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional int32 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class USTOREProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.USTOREProof) */ {
 public:
  inline USTOREProof() : USTOREProof(nullptr) {}
  virtual ~USTOREProof();

  USTOREProof(const USTOREProof& from);
  USTOREProof(USTOREProof&& from) noexcept
    : USTOREProof() {
    *this = ::std::move(from);
  }

  inline USTOREProof& operator=(const USTOREProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline USTOREProof& operator=(USTOREProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const USTOREProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const USTOREProof* internal_default_instance() {
    return reinterpret_cast<const USTOREProof*>(
               &_USTOREProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(USTOREProof& a, USTOREProof& b) {
    a.Swap(&b);
  }
  inline void Swap(USTOREProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(USTOREProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline USTOREProof* New() const final {
    return CreateMaybeMessage<USTOREProof>(nullptr);
  }

  USTOREProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<USTOREProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const USTOREProof& from);
  void MergeFrom(const USTOREProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(USTOREProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.USTOREProof";
  }
  protected:
  explicit USTOREProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kListChunksFieldNumber = 2,
    kListPosFieldNumber = 3,
    kMapChunksFieldNumber = 4,
    kMapPosFieldNumber = 5,
    kKeysFieldNumber = 6,
    kRangesFieldNumber = 7,
  };
  // repeated bytes value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // repeated bytes list_chunks = 2;
  int list_chunks_size() const;
  private:
  int _internal_list_chunks_size() const;
  public:
  void clear_list_chunks();
  const std::string& list_chunks(int index) const;
  std::string* mutable_list_chunks(int index);
  void set_list_chunks(int index, const std::string& value);
  void set_list_chunks(int index, std::string&& value);
  void set_list_chunks(int index, const char* value);
  void set_list_chunks(int index, const void* value, size_t size);
  std::string* add_list_chunks();
  void add_list_chunks(const std::string& value);
  void add_list_chunks(std::string&& value);
  void add_list_chunks(const char* value);
  void add_list_chunks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& list_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_list_chunks();
  private:
  const std::string& _internal_list_chunks(int index) const;
  std::string* _internal_add_list_chunks();
  public:

  // repeated int32 list_pos = 3;
  int list_pos_size() const;
  private:
  int _internal_list_pos_size() const;
  public:
  void clear_list_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_list_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_list_pos() const;
  void _internal_add_list_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_list_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 list_pos(int index) const;
  void set_list_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_list_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      list_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_list_pos();

  // repeated bytes map_chunks = 4;
  int map_chunks_size() const;
  private:
  int _internal_map_chunks_size() const;
  public:
  void clear_map_chunks();
  const std::string& map_chunks(int index) const;
  std::string* mutable_map_chunks(int index);
  void set_map_chunks(int index, const std::string& value);
  void set_map_chunks(int index, std::string&& value);
  void set_map_chunks(int index, const char* value);
  void set_map_chunks(int index, const void* value, size_t size);
  std::string* add_map_chunks();
  void add_map_chunks(const std::string& value);
  void add_map_chunks(std::string&& value);
  void add_map_chunks(const char* value);
  void add_map_chunks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& map_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_map_chunks();
  private:
  const std::string& _internal_map_chunks(int index) const;
  std::string* _internal_add_map_chunks();
  public:

  // repeated int32 map_pos = 5;
  int map_pos_size() const;
  private:
  int _internal_map_pos_size() const;
  public:
  void clear_map_pos();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_map_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_map_pos() const;
  void _internal_add_map_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_map_pos();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 map_pos(int index) const;
  void set_map_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_map_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      map_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_map_pos();

  // repeated bytes keys = 6;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated .strongstore.proto.Range ranges = 7;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::strongstore::proto::Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Range >*
      mutable_ranges();
  private:
  const ::strongstore::proto::Range& _internal_ranges(int index) const;
  ::strongstore::proto::Range* _internal_add_ranges();
  public:
  const ::strongstore::proto::Range& ranges(int index) const;
  ::strongstore::proto::Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Range >&
      ranges() const;

  // @@protoc_insertion_point(class_scope:strongstore.proto.USTOREProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> list_chunks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > list_pos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> map_chunks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > map_pos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Range > ranges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Reply_Digest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Reply.Digest) */ {
 public:
  inline Reply_Digest() : Reply_Digest(nullptr) {}
  virtual ~Reply_Digest();

  Reply_Digest(const Reply_Digest& from);
  Reply_Digest(Reply_Digest&& from) noexcept
    : Reply_Digest() {
    *this = ::std::move(from);
  }

  inline Reply_Digest& operator=(const Reply_Digest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply_Digest& operator=(Reply_Digest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply_Digest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply_Digest* internal_default_instance() {
    return reinterpret_cast<const Reply_Digest*>(
               &_Reply_Digest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Reply_Digest& a, Reply_Digest& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply_Digest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply_Digest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply_Digest* New() const final {
    return CreateMaybeMessage<Reply_Digest>(nullptr);
  }

  Reply_Digest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply_Digest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply_Digest& from);
  void MergeFrom(const Reply_Digest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply_Digest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Reply.Digest";
  }
  protected:
  explicit Reply_Digest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kMptHashFieldNumber = 3,
    kBlockFieldNumber = 1,
  };
  // optional bytes hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional bytes mptHash = 3;
  bool has_mpthash() const;
  private:
  bool _internal_has_mpthash() const;
  public:
  void clear_mpthash();
  const std::string& mpthash() const;
  void set_mpthash(const std::string& value);
  void set_mpthash(std::string&& value);
  void set_mpthash(const char* value);
  void set_mpthash(const void* value, size_t size);
  std::string* mutable_mpthash();
  std::string* release_mpthash();
  void set_allocated_mpthash(std::string* mpthash);
  private:
  const std::string& _internal_mpthash() const;
  void _internal_set_mpthash(const std::string& value);
  std::string* _internal_mutable_mpthash();
  public:

  // optional int64 block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  ::PROTOBUF_NAMESPACE_ID::int64 block() const;
  void set_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_block() const;
  void _internal_set_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Reply.Digest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mpthash_;
  ::PROTOBUF_NAMESPACE_ID::int64 block_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Reply_KV PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Reply.KV) */ {
 public:
  inline Reply_KV() : Reply_KV(nullptr) {}
  virtual ~Reply_KV();

  Reply_KV(const Reply_KV& from);
  Reply_KV(Reply_KV&& from) noexcept
    : Reply_KV() {
    *this = ::std::move(from);
  }

  inline Reply_KV& operator=(const Reply_KV& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply_KV& operator=(Reply_KV&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply_KV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply_KV* internal_default_instance() {
    return reinterpret_cast<const Reply_KV*>(
               &_Reply_KV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Reply_KV& a, Reply_KV& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply_KV* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply_KV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply_KV* New() const final {
    return CreateMaybeMessage<Reply_KV>(nullptr);
  }

  Reply_KV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply_KV>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply_KV& from);
  void MergeFrom(const Reply_KV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply_KV* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Reply.KV";
  }
  protected:
  explicit Reply_KV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
    kEstimateBlockFieldNumber = 3,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  void set_val(const std::string& value);
  void set_val(std::string&& value);
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  std::string* mutable_val();
  std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // optional int64 estimate_block = 3;
  bool has_estimate_block() const;
  private:
  bool _internal_has_estimate_block() const;
  public:
  void clear_estimate_block();
  ::PROTOBUF_NAMESPACE_ID::int64 estimate_block() const;
  void set_estimate_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_estimate_block() const;
  void _internal_set_estimate_block(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Reply.KV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  ::PROTOBUF_NAMESPACE_ID::int64 estimate_block_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Reply_SQLLedgerAudit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Reply.SQLLedgerAudit) */ {
 public:
  inline Reply_SQLLedgerAudit() : Reply_SQLLedgerAudit(nullptr) {}
  virtual ~Reply_SQLLedgerAudit();

  Reply_SQLLedgerAudit(const Reply_SQLLedgerAudit& from);
  Reply_SQLLedgerAudit(Reply_SQLLedgerAudit&& from) noexcept
    : Reply_SQLLedgerAudit() {
    *this = ::std::move(from);
  }

  inline Reply_SQLLedgerAudit& operator=(const Reply_SQLLedgerAudit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply_SQLLedgerAudit& operator=(Reply_SQLLedgerAudit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply_SQLLedgerAudit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply_SQLLedgerAudit* internal_default_instance() {
    return reinterpret_cast<const Reply_SQLLedgerAudit*>(
               &_Reply_SQLLedgerAudit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Reply_SQLLedgerAudit& a, Reply_SQLLedgerAudit& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply_SQLLedgerAudit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply_SQLLedgerAudit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply_SQLLedgerAudit* New() const final {
    return CreateMaybeMessage<Reply_SQLLedgerAudit>(nullptr);
  }

  Reply_SQLLedgerAudit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply_SQLLedgerAudit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply_SQLLedgerAudit& from);
  void MergeFrom(const Reply_SQLLedgerAudit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply_SQLLedgerAudit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Reply.SQLLedgerAudit";
  }
  protected:
  explicit Reply_SQLLedgerAudit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 4,
    kDigestFieldNumber = 2,
    kTxnsFieldNumber = 3,
    kBlockNoFieldNumber = 1,
  };
  // repeated bytes blocks = 4;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  const std::string& blocks(int index) const;
  std::string* mutable_blocks(int index);
  void set_blocks(int index, const std::string& value);
  void set_blocks(int index, std::string&& value);
  void set_blocks(int index, const char* value);
  void set_blocks(int index, const void* value, size_t size);
  std::string* add_blocks();
  void add_blocks(const std::string& value);
  void add_blocks(std::string&& value);
  void add_blocks(const char* value);
  void add_blocks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blocks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blocks();
  private:
  const std::string& _internal_blocks(int index) const;
  std::string* _internal_add_blocks();
  public:

  // optional bytes digest = 2;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  void set_digest(const std::string& value);
  void set_digest(std::string&& value);
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  std::string* mutable_digest();
  std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional bytes txns = 3;
  bool has_txns() const;
  private:
  bool _internal_has_txns() const;
  public:
  void clear_txns();
  const std::string& txns() const;
  void set_txns(const std::string& value);
  void set_txns(std::string&& value);
  void set_txns(const char* value);
  void set_txns(const void* value, size_t size);
  std::string* mutable_txns();
  std::string* release_txns();
  void set_allocated_txns(std::string* txns);
  private:
  const std::string& _internal_txns() const;
  void _internal_set_txns(const std::string& value);
  std::string* _internal_mutable_txns();
  public:

  // optional int64 block_no = 1;
  bool has_block_no() const;
  private:
  bool _internal_has_block_no() const;
  public:
  void clear_block_no();
  ::PROTOBUF_NAMESPACE_ID::int64 block_no() const;
  void set_block_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_block_no() const;
  void _internal_set_block_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Reply.SQLLedgerAudit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txns_;
  ::PROTOBUF_NAMESPACE_ID::int64 block_no_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Reply_LedgerDBAudit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Reply.LedgerDBAudit) */ {
 public:
  inline Reply_LedgerDBAudit() : Reply_LedgerDBAudit(nullptr) {}
  virtual ~Reply_LedgerDBAudit();

  Reply_LedgerDBAudit(const Reply_LedgerDBAudit& from);
  Reply_LedgerDBAudit(Reply_LedgerDBAudit&& from) noexcept
    : Reply_LedgerDBAudit() {
    *this = ::std::move(from);
  }

  inline Reply_LedgerDBAudit& operator=(const Reply_LedgerDBAudit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply_LedgerDBAudit& operator=(Reply_LedgerDBAudit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply_LedgerDBAudit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply_LedgerDBAudit* internal_default_instance() {
    return reinterpret_cast<const Reply_LedgerDBAudit*>(
               &_Reply_LedgerDBAudit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Reply_LedgerDBAudit& a, Reply_LedgerDBAudit& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply_LedgerDBAudit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply_LedgerDBAudit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply_LedgerDBAudit* New() const final {
    return CreateMaybeMessage<Reply_LedgerDBAudit>(nullptr);
  }

  Reply_LedgerDBAudit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply_LedgerDBAudit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply_LedgerDBAudit& from);
  void MergeFrom(const Reply_LedgerDBAudit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply_LedgerDBAudit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Reply.LedgerDBAudit";
  }
  protected:
  explicit Reply_LedgerDBAudit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommitsFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kMptproofsFieldNumber = 6,
    kDigestFieldNumber = 1,
    kCommitSeqFieldNumber = 2,
    kFirstBlockSeqFieldNumber = 3,
  };
  // repeated bytes commits = 4;
  int commits_size() const;
  private:
  int _internal_commits_size() const;
  public:
  void clear_commits();
  const std::string& commits(int index) const;
  std::string* mutable_commits(int index);
  void set_commits(int index, const std::string& value);
  void set_commits(int index, std::string&& value);
  void set_commits(int index, const char* value);
  void set_commits(int index, const void* value, size_t size);
  std::string* add_commits();
  void add_commits(const std::string& value);
  void add_commits(std::string&& value);
  void add_commits(const char* value);
  void add_commits(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& commits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_commits();
  private:
  const std::string& _internal_commits(int index) const;
  std::string* _internal_add_commits();
  public:

  // repeated bytes blocks = 5;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  const std::string& blocks(int index) const;
  std::string* mutable_blocks(int index);
  void set_blocks(int index, const std::string& value);
  void set_blocks(int index, std::string&& value);
  void set_blocks(int index, const char* value);
  void set_blocks(int index, const void* value, size_t size);
  std::string* add_blocks();
  void add_blocks(const std::string& value);
  void add_blocks(std::string&& value);
  void add_blocks(const char* value);
  void add_blocks(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blocks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blocks();
  private:
  const std::string& _internal_blocks(int index) const;
  std::string* _internal_add_blocks();
  public:

  // repeated .strongstore.proto.MPTProof mptproofs = 6;
  int mptproofs_size() const;
  private:
  int _internal_mptproofs_size() const;
  public:
  void clear_mptproofs();
  ::strongstore::proto::MPTProof* mutable_mptproofs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::MPTProof >*
      mutable_mptproofs();
  private:
  const ::strongstore::proto::MPTProof& _internal_mptproofs(int index) const;
  ::strongstore::proto::MPTProof* _internal_add_mptproofs();
  public:
  const ::strongstore::proto::MPTProof& mptproofs(int index) const;
  ::strongstore::proto::MPTProof* add_mptproofs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::MPTProof >&
      mptproofs() const;

  // optional bytes digest = 1;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  void set_digest(const std::string& value);
  void set_digest(std::string&& value);
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  std::string* mutable_digest();
  std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional int64 commit_seq = 2;
  bool has_commit_seq() const;
  private:
  bool _internal_has_commit_seq() const;
  public:
  void clear_commit_seq();
  ::PROTOBUF_NAMESPACE_ID::int64 commit_seq() const;
  void set_commit_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_commit_seq() const;
  void _internal_set_commit_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 first_block_seq = 3;
  bool has_first_block_seq() const;
  private:
  bool _internal_has_first_block_seq() const;
  public:
  void clear_first_block_seq();
  ::PROTOBUF_NAMESPACE_ID::int64 first_block_seq() const;
  void set_first_block_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_first_block_seq() const;
  void _internal_set_first_block_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Reply.LedgerDBAudit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> commits_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blocks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::MPTProof > mptproofs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::int64 commit_seq_;
  ::PROTOBUF_NAMESPACE_ID::int64 first_block_seq_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// -------------------------------------------------------------------

class Reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strongstore.proto.Reply) */ {
 public:
  inline Reply() : Reply(nullptr) {}
  virtual ~Reply();

  Reply(const Reply& from);
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply& operator=(Reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply* New() const final {
    return CreateMaybeMessage<Reply>(nullptr);
  }

  Reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strongstore.proto.Reply";
  }
  protected:
  explicit Reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_strong_2dproto_2eproto);
    return ::descriptor_table_strong_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Reply_Digest Digest;
  typedef Reply_KV KV;
  typedef Reply_SQLLedgerAudit SQLLedgerAudit;
  typedef Reply_LedgerDBAudit LedgerDBAudit;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 5,
    kTimestampsFieldNumber = 6,
    kQproofFieldNumber = 8,
    kProofFieldNumber = 9,
    kBlockdataFieldNumber = 10,
    kSproofFieldNumber = 11,
    kValueFieldNumber = 2,
    kDigestFieldNumber = 4,
    kUproofFieldNumber = 7,
    kSauditFieldNumber = 12,
    kLauditFieldNumber = 13,
    kTimestampFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .strongstore.proto.Reply.KV values = 5;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::strongstore::proto::Reply_KV* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Reply_KV >*
      mutable_values();
  private:
  const ::strongstore::proto::Reply_KV& _internal_values(int index) const;
  ::strongstore::proto::Reply_KV* _internal_add_values();
  public:
  const ::strongstore::proto::Reply_KV& values(int index) const;
  ::strongstore::proto::Reply_KV* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Reply_KV >&
      values() const;

  // repeated int64 timestamps = 6;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_timestamps() const;
  void _internal_add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_timestamps();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 timestamps(int index) const;
  void set_timestamps(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_timestamps();

  // repeated .strongstore.proto.QLDBProof qproof = 8;
  int qproof_size() const;
  private:
  int _internal_qproof_size() const;
  public:
  void clear_qproof();
  ::strongstore::proto::QLDBProof* mutable_qproof(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::QLDBProof >*
      mutable_qproof();
  private:
  const ::strongstore::proto::QLDBProof& _internal_qproof(int index) const;
  ::strongstore::proto::QLDBProof* _internal_add_qproof();
  public:
  const ::strongstore::proto::QLDBProof& qproof(int index) const;
  ::strongstore::proto::QLDBProof* add_qproof();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::QLDBProof >&
      qproof() const;

  // repeated .strongstore.proto.LedgerDBProof proof = 9;
  int proof_size() const;
  private:
  int _internal_proof_size() const;
  public:
  void clear_proof();
  ::strongstore::proto::LedgerDBProof* mutable_proof(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::LedgerDBProof >*
      mutable_proof();
  private:
  const ::strongstore::proto::LedgerDBProof& _internal_proof(int index) const;
  ::strongstore::proto::LedgerDBProof* _internal_add_proof();
  public:
  const ::strongstore::proto::LedgerDBProof& proof(int index) const;
  ::strongstore::proto::LedgerDBProof* add_proof();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::LedgerDBProof >&
      proof() const;

  // repeated bytes blockdata = 10;
  int blockdata_size() const;
  private:
  int _internal_blockdata_size() const;
  public:
  void clear_blockdata();
  const std::string& blockdata(int index) const;
  std::string* mutable_blockdata(int index);
  void set_blockdata(int index, const std::string& value);
  void set_blockdata(int index, std::string&& value);
  void set_blockdata(int index, const char* value);
  void set_blockdata(int index, const void* value, size_t size);
  std::string* add_blockdata();
  void add_blockdata(const std::string& value);
  void add_blockdata(std::string&& value);
  void add_blockdata(const char* value);
  void add_blockdata(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blockdata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blockdata();
  private:
  const std::string& _internal_blockdata(int index) const;
  std::string* _internal_add_blockdata();
  public:

  // repeated .strongstore.proto.SQLLedgerProof sproof = 11;
  int sproof_size() const;
  private:
  int _internal_sproof_size() const;
  public:
  void clear_sproof();
  ::strongstore::proto::SQLLedgerProof* mutable_sproof(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::SQLLedgerProof >*
      mutable_sproof();
  private:
  const ::strongstore::proto::SQLLedgerProof& _internal_sproof(int index) const;
  ::strongstore::proto::SQLLedgerProof* _internal_add_sproof();
  public:
  const ::strongstore::proto::SQLLedgerProof& sproof(int index) const;
  ::strongstore::proto::SQLLedgerProof* add_sproof();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::SQLLedgerProof >&
      sproof() const;

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .strongstore.proto.Reply.Digest digest = 4;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const ::strongstore::proto::Reply_Digest& digest() const;
  ::strongstore::proto::Reply_Digest* release_digest();
  ::strongstore::proto::Reply_Digest* mutable_digest();
  void set_allocated_digest(::strongstore::proto::Reply_Digest* digest);
  private:
  const ::strongstore::proto::Reply_Digest& _internal_digest() const;
  ::strongstore::proto::Reply_Digest* _internal_mutable_digest();
  public:
  void unsafe_arena_set_allocated_digest(
      ::strongstore::proto::Reply_Digest* digest);
  ::strongstore::proto::Reply_Digest* unsafe_arena_release_digest();

  // optional .strongstore.proto.USTOREProof uproof = 7;
  bool has_uproof() const;
  private:
  bool _internal_has_uproof() const;
  public:
  void clear_uproof();
  const ::strongstore::proto::USTOREProof& uproof() const;
  ::strongstore::proto::USTOREProof* release_uproof();
  ::strongstore::proto::USTOREProof* mutable_uproof();
  void set_allocated_uproof(::strongstore::proto::USTOREProof* uproof);
  private:
  const ::strongstore::proto::USTOREProof& _internal_uproof() const;
  ::strongstore::proto::USTOREProof* _internal_mutable_uproof();
  public:
  void unsafe_arena_set_allocated_uproof(
      ::strongstore::proto::USTOREProof* uproof);
  ::strongstore::proto::USTOREProof* unsafe_arena_release_uproof();

  // optional .strongstore.proto.Reply.SQLLedgerAudit saudit = 12;
  bool has_saudit() const;
  private:
  bool _internal_has_saudit() const;
  public:
  void clear_saudit();
  const ::strongstore::proto::Reply_SQLLedgerAudit& saudit() const;
  ::strongstore::proto::Reply_SQLLedgerAudit* release_saudit();
  ::strongstore::proto::Reply_SQLLedgerAudit* mutable_saudit();
  void set_allocated_saudit(::strongstore::proto::Reply_SQLLedgerAudit* saudit);
  private:
  const ::strongstore::proto::Reply_SQLLedgerAudit& _internal_saudit() const;
  ::strongstore::proto::Reply_SQLLedgerAudit* _internal_mutable_saudit();
  public:
  void unsafe_arena_set_allocated_saudit(
      ::strongstore::proto::Reply_SQLLedgerAudit* saudit);
  ::strongstore::proto::Reply_SQLLedgerAudit* unsafe_arena_release_saudit();

  // optional .strongstore.proto.Reply.LedgerDBAudit laudit = 13;
  bool has_laudit() const;
  private:
  bool _internal_has_laudit() const;
  public:
  void clear_laudit();
  const ::strongstore::proto::Reply_LedgerDBAudit& laudit() const;
  ::strongstore::proto::Reply_LedgerDBAudit* release_laudit();
  ::strongstore::proto::Reply_LedgerDBAudit* mutable_laudit();
  void set_allocated_laudit(::strongstore::proto::Reply_LedgerDBAudit* laudit);
  private:
  const ::strongstore::proto::Reply_LedgerDBAudit& _internal_laudit() const;
  ::strongstore::proto::Reply_LedgerDBAudit* _internal_mutable_laudit();
  public:
  void unsafe_arena_set_allocated_laudit(
      ::strongstore::proto::Reply_LedgerDBAudit* laudit);
  ::strongstore::proto::Reply_LedgerDBAudit* unsafe_arena_release_laudit();

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:strongstore.proto.Reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Reply_KV > values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > timestamps_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::QLDBProof > qproof_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::LedgerDBProof > proof_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blockdata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::SQLLedgerProof > sproof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::strongstore::proto::Reply_Digest* digest_;
  ::strongstore::proto::USTOREProof* uproof_;
  ::strongstore::proto::Reply_SQLLedgerAudit* saudit_;
  ::strongstore::proto::Reply_LedgerDBAudit* laudit_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_strong_2dproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetMessage

// required string key = 1;
inline bool GetMessage::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetMessage::has_key() const {
  return _internal_has_key();
}
inline void GetMessage::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetMessage::key() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.GetMessage.key)
  return _internal_key();
}
inline void GetMessage::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.GetMessage.key)
}
inline std::string* GetMessage::mutable_key() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.GetMessage.key)
  return _internal_mutable_key();
}
inline const std::string& GetMessage::_internal_key() const {
  return key_.Get();
}
inline void GetMessage::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetMessage::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.GetMessage.key)
}
inline void GetMessage::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.GetMessage.key)
}
inline void GetMessage::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.GetMessage.key)
}
inline std::string* GetMessage::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetMessage::release_key() {
  // @@protoc_insertion_point(field_release:strongstore.proto.GetMessage.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetMessage::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.GetMessage.key)
}

// optional .TimestampMessage timestamp = 2;
inline bool GetMessage::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || timestamp_ != nullptr);
  return value;
}
inline bool GetMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::TimestampMessage& GetMessage::_internal_timestamp() const {
  const ::TimestampMessage* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::TimestampMessage*>(
      &::_TimestampMessage_default_instance_);
}
inline const ::TimestampMessage& GetMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.GetMessage.timestamp)
  return _internal_timestamp();
}
inline void GetMessage::unsafe_arena_set_allocated_timestamp(
    ::TimestampMessage* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.GetMessage.timestamp)
}
inline ::TimestampMessage* GetMessage::release_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
  ::TimestampMessage* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TimestampMessage* GetMessage::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:strongstore.proto.GetMessage.timestamp)
  _has_bits_[0] &= ~0x00000002u;
  ::TimestampMessage* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::TimestampMessage* GetMessage::_internal_mutable_timestamp() {
  _has_bits_[0] |= 0x00000002u;
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::TimestampMessage>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::TimestampMessage* GetMessage::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.GetMessage.timestamp)
  return _internal_mutable_timestamp();
}
inline void GetMessage::set_allocated_timestamp(::TimestampMessage* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.GetMessage.timestamp)
}

// -------------------------------------------------------------------

// PrepareMessage

// required .TransactionMessage txn = 1;
inline bool PrepareMessage::_internal_has_txn() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || txn_ != nullptr);
  return value;
}
inline bool PrepareMessage::has_txn() const {
  return _internal_has_txn();
}
inline const ::TransactionMessage& PrepareMessage::_internal_txn() const {
  const ::TransactionMessage* p = txn_;
  return p != nullptr ? *p : *reinterpret_cast<const ::TransactionMessage*>(
      &::_TransactionMessage_default_instance_);
}
inline const ::TransactionMessage& PrepareMessage::txn() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.PrepareMessage.txn)
  return _internal_txn();
}
inline void PrepareMessage::unsafe_arena_set_allocated_txn(
    ::TransactionMessage* txn) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  txn_ = txn;
  if (txn) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.PrepareMessage.txn)
}
inline ::TransactionMessage* PrepareMessage::release_txn() {
  _has_bits_[0] &= ~0x00000001u;
  ::TransactionMessage* temp = txn_;
  txn_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TransactionMessage* PrepareMessage::unsafe_arena_release_txn() {
  // @@protoc_insertion_point(field_release:strongstore.proto.PrepareMessage.txn)
  _has_bits_[0] &= ~0x00000001u;
  ::TransactionMessage* temp = txn_;
  txn_ = nullptr;
  return temp;
}
inline ::TransactionMessage* PrepareMessage::_internal_mutable_txn() {
  _has_bits_[0] |= 0x00000001u;
  if (txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::TransactionMessage>(GetArena());
    txn_ = p;
  }
  return txn_;
}
inline ::TransactionMessage* PrepareMessage::mutable_txn() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.PrepareMessage.txn)
  return _internal_mutable_txn();
}
inline void PrepareMessage::set_allocated_txn(::TransactionMessage* txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  if (txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn)->GetArena();
    if (message_arena != submessage_arena) {
      txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.PrepareMessage.txn)
}

// optional uint64 timestamp = 2;
inline bool PrepareMessage::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrepareMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PrepareMessage::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PrepareMessage::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PrepareMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.PrepareMessage.timestamp)
  return _internal_timestamp();
}
inline void PrepareMessage::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void PrepareMessage::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.PrepareMessage.timestamp)
}

// -------------------------------------------------------------------

// CommitMessage

// required uint64 timestamp = 1;
inline bool CommitMessage::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommitMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CommitMessage::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommitMessage::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommitMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.CommitMessage.timestamp)
  return _internal_timestamp();
}
inline void CommitMessage::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void CommitMessage::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.CommitMessage.timestamp)
}

// -------------------------------------------------------------------

// AbortMessage

// required .TransactionMessage txn = 1;
inline bool AbortMessage::_internal_has_txn() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || txn_ != nullptr);
  return value;
}
inline bool AbortMessage::has_txn() const {
  return _internal_has_txn();
}
inline const ::TransactionMessage& AbortMessage::_internal_txn() const {
  const ::TransactionMessage* p = txn_;
  return p != nullptr ? *p : *reinterpret_cast<const ::TransactionMessage*>(
      &::_TransactionMessage_default_instance_);
}
inline const ::TransactionMessage& AbortMessage::txn() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.AbortMessage.txn)
  return _internal_txn();
}
inline void AbortMessage::unsafe_arena_set_allocated_txn(
    ::TransactionMessage* txn) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  txn_ = txn;
  if (txn) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.AbortMessage.txn)
}
inline ::TransactionMessage* AbortMessage::release_txn() {
  _has_bits_[0] &= ~0x00000001u;
  ::TransactionMessage* temp = txn_;
  txn_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TransactionMessage* AbortMessage::unsafe_arena_release_txn() {
  // @@protoc_insertion_point(field_release:strongstore.proto.AbortMessage.txn)
  _has_bits_[0] &= ~0x00000001u;
  ::TransactionMessage* temp = txn_;
  txn_ = nullptr;
  return temp;
}
inline ::TransactionMessage* AbortMessage::_internal_mutable_txn() {
  _has_bits_[0] |= 0x00000001u;
  if (txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::TransactionMessage>(GetArena());
    txn_ = p;
  }
  return txn_;
}
inline ::TransactionMessage* AbortMessage::mutable_txn() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.AbortMessage.txn)
  return _internal_mutable_txn();
}
inline void AbortMessage::set_allocated_txn(::TransactionMessage* txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  if (txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn)->GetArena();
    if (message_arena != submessage_arena) {
      txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.AbortMessage.txn)
}

// -------------------------------------------------------------------

// VerifyMessage

// optional int64 block = 1;
inline bool VerifyMessage::_internal_has_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerifyMessage::has_block() const {
  return _internal_has_block();
}
inline void VerifyMessage::clear_block() {
  block_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VerifyMessage::_internal_block() const {
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VerifyMessage::block() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.VerifyMessage.block)
  return _internal_block();
}
inline void VerifyMessage::_internal_set_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  block_ = value;
}
inline void VerifyMessage::set_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.VerifyMessage.block)
}

// repeated bytes keys = 2;
inline int VerifyMessage::_internal_keys_size() const {
  return keys_.size();
}
inline int VerifyMessage::keys_size() const {
  return _internal_keys_size();
}
inline void VerifyMessage::clear_keys() {
  keys_.Clear();
}
inline std::string* VerifyMessage::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.VerifyMessage.keys)
  return _internal_add_keys();
}
inline const std::string& VerifyMessage::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& VerifyMessage::keys(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.VerifyMessage.keys)
  return _internal_keys(index);
}
inline std::string* VerifyMessage::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.VerifyMessage.keys)
  return keys_.Mutable(index);
}
inline void VerifyMessage::set_keys(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.VerifyMessage.keys)
  keys_.Mutable(index)->assign(value);
}
inline void VerifyMessage::set_keys(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.VerifyMessage.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
inline void VerifyMessage::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.VerifyMessage.keys)
}
inline void VerifyMessage::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.VerifyMessage.keys)
}
inline std::string* VerifyMessage::_internal_add_keys() {
  return keys_.Add();
}
inline void VerifyMessage::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.VerifyMessage.keys)
}
inline void VerifyMessage::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.VerifyMessage.keys)
}
inline void VerifyMessage::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.VerifyMessage.keys)
}
inline void VerifyMessage::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.VerifyMessage.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VerifyMessage::keys() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.VerifyMessage.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VerifyMessage::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.VerifyMessage.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// AuditMessage

// optional int64 seq = 1;
inline bool AuditMessage::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuditMessage::has_seq() const {
  return _internal_has_seq();
}
inline void AuditMessage::clear_seq() {
  seq_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuditMessage::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuditMessage::seq() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.AuditMessage.seq)
  return _internal_seq();
}
inline void AuditMessage::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  seq_ = value;
}
inline void AuditMessage::set_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.AuditMessage.seq)
}

// -------------------------------------------------------------------

// VersionMessage_VersionedKey

// optional string key = 1;
inline bool VersionMessage_VersionedKey::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionMessage_VersionedKey::has_key() const {
  return _internal_has_key();
}
inline void VersionMessage_VersionedKey::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionMessage_VersionedKey::key() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.VersionMessage.VersionedKey.key)
  return _internal_key();
}
inline void VersionMessage_VersionedKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.VersionMessage.VersionedKey.key)
}
inline std::string* VersionMessage_VersionedKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.VersionMessage.VersionedKey.key)
  return _internal_mutable_key();
}
inline const std::string& VersionMessage_VersionedKey::_internal_key() const {
  return key_.Get();
}
inline void VersionMessage_VersionedKey::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VersionMessage_VersionedKey::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.VersionMessage.VersionedKey.key)
}
inline void VersionMessage_VersionedKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.VersionMessage.VersionedKey.key)
}
inline void VersionMessage_VersionedKey::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.VersionMessage.VersionedKey.key)
}
inline std::string* VersionMessage_VersionedKey::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VersionMessage_VersionedKey::release_key() {
  // @@protoc_insertion_point(field_release:strongstore.proto.VersionMessage.VersionedKey.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VersionMessage_VersionedKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.VersionMessage.VersionedKey.key)
}

// optional int32 nversions = 2;
inline bool VersionMessage_VersionedKey::_internal_has_nversions() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VersionMessage_VersionedKey::has_nversions() const {
  return _internal_has_nversions();
}
inline void VersionMessage_VersionedKey::clear_nversions() {
  nversions_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VersionMessage_VersionedKey::_internal_nversions() const {
  return nversions_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VersionMessage_VersionedKey::nversions() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.VersionMessage.VersionedKey.nversions)
  return _internal_nversions();
}
inline void VersionMessage_VersionedKey::_internal_set_nversions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  nversions_ = value;
}
inline void VersionMessage_VersionedKey::set_nversions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nversions(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.VersionMessage.VersionedKey.nversions)
}

// -------------------------------------------------------------------

// VersionMessage

// repeated .strongstore.proto.VersionMessage.VersionedKey versionedKeys = 1;
inline int VersionMessage::_internal_versionedkeys_size() const {
  return versionedkeys_.size();
}
inline int VersionMessage::versionedkeys_size() const {
  return _internal_versionedkeys_size();
}
inline void VersionMessage::clear_versionedkeys() {
  versionedkeys_.Clear();
}
inline ::strongstore::proto::VersionMessage_VersionedKey* VersionMessage::mutable_versionedkeys(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.VersionMessage.versionedKeys)
  return versionedkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::VersionMessage_VersionedKey >*
VersionMessage::mutable_versionedkeys() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.VersionMessage.versionedKeys)
  return &versionedkeys_;
}
inline const ::strongstore::proto::VersionMessage_VersionedKey& VersionMessage::_internal_versionedkeys(int index) const {
  return versionedkeys_.Get(index);
}
inline const ::strongstore::proto::VersionMessage_VersionedKey& VersionMessage::versionedkeys(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.VersionMessage.versionedKeys)
  return _internal_versionedkeys(index);
}
inline ::strongstore::proto::VersionMessage_VersionedKey* VersionMessage::_internal_add_versionedkeys() {
  return versionedkeys_.Add();
}
inline ::strongstore::proto::VersionMessage_VersionedKey* VersionMessage::add_versionedkeys() {
  // @@protoc_insertion_point(field_add:strongstore.proto.VersionMessage.versionedKeys)
  return _internal_add_versionedkeys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::VersionMessage_VersionedKey >&
VersionMessage::versionedkeys() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.VersionMessage.versionedKeys)
  return versionedkeys_;
}

// -------------------------------------------------------------------

// RangeMessage

// optional string from = 1;
inline bool RangeMessage::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RangeMessage::has_from() const {
  return _internal_has_from();
}
inline void RangeMessage::clear_from() {
  from_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RangeMessage::from() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.RangeMessage.from)
  return _internal_from();
}
inline void RangeMessage::set_from(const std::string& value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.RangeMessage.from)
}
inline std::string* RangeMessage::mutable_from() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.RangeMessage.from)
  return _internal_mutable_from();
}
inline const std::string& RangeMessage::_internal_from() const {
  return from_.Get();
}
inline void RangeMessage::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RangeMessage::set_from(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.RangeMessage.from)
}
inline void RangeMessage::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.RangeMessage.from)
}
inline void RangeMessage::set_from(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.RangeMessage.from)
}
inline std::string* RangeMessage::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000001u;
  return from_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RangeMessage::release_from() {
  // @@protoc_insertion_point(field_release:strongstore.proto.RangeMessage.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RangeMessage::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.RangeMessage.from)
}

// optional string to = 2;
inline bool RangeMessage::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RangeMessage::has_to() const {
  return _internal_has_to();
}
inline void RangeMessage::clear_to() {
  to_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RangeMessage::to() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.RangeMessage.to)
  return _internal_to();
}
inline void RangeMessage::set_to(const std::string& value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.RangeMessage.to)
}
inline std::string* RangeMessage::mutable_to() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.RangeMessage.to)
  return _internal_mutable_to();
}
inline const std::string& RangeMessage::_internal_to() const {
  return to_.Get();
}
inline void RangeMessage::_internal_set_to(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RangeMessage::set_to(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.RangeMessage.to)
}
inline void RangeMessage::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.RangeMessage.to)
}
inline void RangeMessage::set_to(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.RangeMessage.to)
}
inline std::string* RangeMessage::_internal_mutable_to() {
  _has_bits_[0] |= 0x00000002u;
  return to_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RangeMessage::release_to() {
  // @@protoc_insertion_point(field_release:strongstore.proto.RangeMessage.to)
  if (!_internal_has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return to_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RangeMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.RangeMessage.to)
}

// -------------------------------------------------------------------

// BatchGetMessage

// repeated string keys = 1;
inline int BatchGetMessage::_internal_keys_size() const {
  return keys_.size();
}
inline int BatchGetMessage::keys_size() const {
  return _internal_keys_size();
}
inline void BatchGetMessage::clear_keys() {
  keys_.Clear();
}
inline std::string* BatchGetMessage::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.BatchGetMessage.keys)
  return _internal_add_keys();
}
inline const std::string& BatchGetMessage::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& BatchGetMessage::keys(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.BatchGetMessage.keys)
  return _internal_keys(index);
}
inline std::string* BatchGetMessage::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.BatchGetMessage.keys)
  return keys_.Mutable(index);
}
inline void BatchGetMessage::set_keys(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.BatchGetMessage.keys)
  keys_.Mutable(index)->assign(value);
}
inline void BatchGetMessage::set_keys(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.BatchGetMessage.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
inline void BatchGetMessage::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.BatchGetMessage.keys)
}
inline void BatchGetMessage::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.BatchGetMessage.keys)
}
inline std::string* BatchGetMessage::_internal_add_keys() {
  return keys_.Add();
}
inline void BatchGetMessage::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.BatchGetMessage.keys)
}
inline void BatchGetMessage::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.BatchGetMessage.keys)
}
inline void BatchGetMessage::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.BatchGetMessage.keys)
}
inline void BatchGetMessage::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.BatchGetMessage.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchGetMessage::keys() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.BatchGetMessage.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchGetMessage::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.BatchGetMessage.keys)
  return &keys_;
}

// optional .TimestampMessage timestamp = 2;
inline bool BatchGetMessage::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || timestamp_ != nullptr);
  return value;
}
inline bool BatchGetMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::TimestampMessage& BatchGetMessage::_internal_timestamp() const {
  const ::TimestampMessage* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::TimestampMessage*>(
      &::_TimestampMessage_default_instance_);
}
inline const ::TimestampMessage& BatchGetMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.BatchGetMessage.timestamp)
  return _internal_timestamp();
}
inline void BatchGetMessage::unsafe_arena_set_allocated_timestamp(
    ::TimestampMessage* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.BatchGetMessage.timestamp)
}
inline ::TimestampMessage* BatchGetMessage::release_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
  ::TimestampMessage* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TimestampMessage* BatchGetMessage::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:strongstore.proto.BatchGetMessage.timestamp)
  _has_bits_[0] &= ~0x00000001u;
  ::TimestampMessage* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::TimestampMessage* BatchGetMessage::_internal_mutable_timestamp() {
  _has_bits_[0] |= 0x00000001u;
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::TimestampMessage>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::TimestampMessage* BatchGetMessage::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.BatchGetMessage.timestamp)
  return _internal_mutable_timestamp();
}
inline void BatchGetMessage::set_allocated_timestamp(::TimestampMessage* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.BatchGetMessage.timestamp)
}

// -------------------------------------------------------------------

// Request

// required .strongstore.proto.Request.Operation op = 1;
inline bool Request::_internal_has_op() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Request::has_op() const {
  return _internal_has_op();
}
inline void Request::clear_op() {
  op_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::strongstore::proto::Request_Operation Request::_internal_op() const {
  return static_cast< ::strongstore::proto::Request_Operation >(op_);
}
inline ::strongstore::proto::Request_Operation Request::op() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.op)
  return _internal_op();
}
inline void Request::_internal_set_op(::strongstore::proto::Request_Operation value) {
  assert(::strongstore::proto::Request_Operation_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  op_ = value;
}
inline void Request::set_op(::strongstore::proto::Request_Operation value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Request.op)
}

// required uint64 txnid = 2;
inline bool Request::_internal_has_txnid() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Request::has_txnid() const {
  return _internal_has_txnid();
}
inline void Request::clear_txnid() {
  txnid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_txnid() const {
  return txnid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::txnid() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.txnid)
  return _internal_txnid();
}
inline void Request::_internal_set_txnid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  txnid_ = value;
}
inline void Request::set_txnid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Request.txnid)
}

// optional .strongstore.proto.GetMessage get = 3;
inline bool Request::_internal_has_get() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || get_ != nullptr);
  return value;
}
inline bool Request::has_get() const {
  return _internal_has_get();
}
inline void Request::clear_get() {
  if (get_ != nullptr) get_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::strongstore::proto::GetMessage& Request::_internal_get() const {
  const ::strongstore::proto::GetMessage* p = get_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::GetMessage*>(
      &::strongstore::proto::_GetMessage_default_instance_);
}
inline const ::strongstore::proto::GetMessage& Request::get() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.get)
  return _internal_get();
}
inline void Request::unsafe_arena_set_allocated_get(
    ::strongstore::proto::GetMessage* get) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_);
  }
  get_ = get;
  if (get) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.get)
}
inline ::strongstore::proto::GetMessage* Request::release_get() {
  _has_bits_[0] &= ~0x00000001u;
  ::strongstore::proto::GetMessage* temp = get_;
  get_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::GetMessage* Request::unsafe_arena_release_get() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.get)
  _has_bits_[0] &= ~0x00000001u;
  ::strongstore::proto::GetMessage* temp = get_;
  get_ = nullptr;
  return temp;
}
inline ::strongstore::proto::GetMessage* Request::_internal_mutable_get() {
  _has_bits_[0] |= 0x00000001u;
  if (get_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::GetMessage>(GetArena());
    get_ = p;
  }
  return get_;
}
inline ::strongstore::proto::GetMessage* Request::mutable_get() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.get)
  return _internal_mutable_get();
}
inline void Request::set_allocated_get(::strongstore::proto::GetMessage* get) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete get_;
  }
  if (get) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get);
    if (message_arena != submessage_arena) {
      get = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  get_ = get;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.get)
}

// optional .strongstore.proto.PrepareMessage prepare = 4;
inline bool Request::_internal_has_prepare() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || prepare_ != nullptr);
  return value;
}
inline bool Request::has_prepare() const {
  return _internal_has_prepare();
}
inline void Request::clear_prepare() {
  if (prepare_ != nullptr) prepare_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::strongstore::proto::PrepareMessage& Request::_internal_prepare() const {
  const ::strongstore::proto::PrepareMessage* p = prepare_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::PrepareMessage*>(
      &::strongstore::proto::_PrepareMessage_default_instance_);
}
inline const ::strongstore::proto::PrepareMessage& Request::prepare() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.prepare)
  return _internal_prepare();
}
inline void Request::unsafe_arena_set_allocated_prepare(
    ::strongstore::proto::PrepareMessage* prepare) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prepare_);
  }
  prepare_ = prepare;
  if (prepare) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.prepare)
}
inline ::strongstore::proto::PrepareMessage* Request::release_prepare() {
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::PrepareMessage* temp = prepare_;
  prepare_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::PrepareMessage* Request::unsafe_arena_release_prepare() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.prepare)
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::PrepareMessage* temp = prepare_;
  prepare_ = nullptr;
  return temp;
}
inline ::strongstore::proto::PrepareMessage* Request::_internal_mutable_prepare() {
  _has_bits_[0] |= 0x00000002u;
  if (prepare_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::PrepareMessage>(GetArena());
    prepare_ = p;
  }
  return prepare_;
}
inline ::strongstore::proto::PrepareMessage* Request::mutable_prepare() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.prepare)
  return _internal_mutable_prepare();
}
inline void Request::set_allocated_prepare(::strongstore::proto::PrepareMessage* prepare) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete prepare_;
  }
  if (prepare) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(prepare);
    if (message_arena != submessage_arena) {
      prepare = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prepare, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prepare_ = prepare;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.prepare)
}

// optional .strongstore.proto.CommitMessage commit = 5;
inline bool Request::_internal_has_commit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || commit_ != nullptr);
  return value;
}
inline bool Request::has_commit() const {
  return _internal_has_commit();
}
inline void Request::clear_commit() {
  if (commit_ != nullptr) commit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::strongstore::proto::CommitMessage& Request::_internal_commit() const {
  const ::strongstore::proto::CommitMessage* p = commit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::CommitMessage*>(
      &::strongstore::proto::_CommitMessage_default_instance_);
}
inline const ::strongstore::proto::CommitMessage& Request::commit() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.commit)
  return _internal_commit();
}
inline void Request::unsafe_arena_set_allocated_commit(
    ::strongstore::proto::CommitMessage* commit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_);
  }
  commit_ = commit;
  if (commit) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.commit)
}
inline ::strongstore::proto::CommitMessage* Request::release_commit() {
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::CommitMessage* temp = commit_;
  commit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::CommitMessage* Request::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.commit)
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::CommitMessage* temp = commit_;
  commit_ = nullptr;
  return temp;
}
inline ::strongstore::proto::CommitMessage* Request::_internal_mutable_commit() {
  _has_bits_[0] |= 0x00000004u;
  if (commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::CommitMessage>(GetArena());
    commit_ = p;
  }
  return commit_;
}
inline ::strongstore::proto::CommitMessage* Request::mutable_commit() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.commit)
  return _internal_mutable_commit();
}
inline void Request::set_allocated_commit(::strongstore::proto::CommitMessage* commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete commit_;
  }
  if (commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(commit);
    if (message_arena != submessage_arena) {
      commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  commit_ = commit;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.commit)
}

// optional .strongstore.proto.AbortMessage abort = 6;
inline bool Request::_internal_has_abort() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || abort_ != nullptr);
  return value;
}
inline bool Request::has_abort() const {
  return _internal_has_abort();
}
inline void Request::clear_abort() {
  if (abort_ != nullptr) abort_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::strongstore::proto::AbortMessage& Request::_internal_abort() const {
  const ::strongstore::proto::AbortMessage* p = abort_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::AbortMessage*>(
      &::strongstore::proto::_AbortMessage_default_instance_);
}
inline const ::strongstore::proto::AbortMessage& Request::abort() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.abort)
  return _internal_abort();
}
inline void Request::unsafe_arena_set_allocated_abort(
    ::strongstore::proto::AbortMessage* abort) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abort_);
  }
  abort_ = abort;
  if (abort) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.abort)
}
inline ::strongstore::proto::AbortMessage* Request::release_abort() {
  _has_bits_[0] &= ~0x00000008u;
  ::strongstore::proto::AbortMessage* temp = abort_;
  abort_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::AbortMessage* Request::unsafe_arena_release_abort() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.abort)
  _has_bits_[0] &= ~0x00000008u;
  ::strongstore::proto::AbortMessage* temp = abort_;
  abort_ = nullptr;
  return temp;
}
inline ::strongstore::proto::AbortMessage* Request::_internal_mutable_abort() {
  _has_bits_[0] |= 0x00000008u;
  if (abort_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::AbortMessage>(GetArena());
    abort_ = p;
  }
  return abort_;
}
inline ::strongstore::proto::AbortMessage* Request::mutable_abort() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.abort)
  return _internal_mutable_abort();
}
inline void Request::set_allocated_abort(::strongstore::proto::AbortMessage* abort) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete abort_;
  }
  if (abort) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(abort);
    if (message_arena != submessage_arena) {
      abort = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abort, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  abort_ = abort;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.abort)
}

// optional .strongstore.proto.VerifyMessage verify = 7;
inline bool Request::_internal_has_verify() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || verify_ != nullptr);
  return value;
}
inline bool Request::has_verify() const {
  return _internal_has_verify();
}
inline void Request::clear_verify() {
  if (verify_ != nullptr) verify_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::strongstore::proto::VerifyMessage& Request::_internal_verify() const {
  const ::strongstore::proto::VerifyMessage* p = verify_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::VerifyMessage*>(
      &::strongstore::proto::_VerifyMessage_default_instance_);
}
inline const ::strongstore::proto::VerifyMessage& Request::verify() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.verify)
  return _internal_verify();
}
inline void Request::unsafe_arena_set_allocated_verify(
    ::strongstore::proto::VerifyMessage* verify) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(verify_);
  }
  verify_ = verify;
  if (verify) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.verify)
}
inline ::strongstore::proto::VerifyMessage* Request::release_verify() {
  _has_bits_[0] &= ~0x00000010u;
  ::strongstore::proto::VerifyMessage* temp = verify_;
  verify_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::VerifyMessage* Request::unsafe_arena_release_verify() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.verify)
  _has_bits_[0] &= ~0x00000010u;
  ::strongstore::proto::VerifyMessage* temp = verify_;
  verify_ = nullptr;
  return temp;
}
inline ::strongstore::proto::VerifyMessage* Request::_internal_mutable_verify() {
  _has_bits_[0] |= 0x00000010u;
  if (verify_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::VerifyMessage>(GetArena());
    verify_ = p;
  }
  return verify_;
}
inline ::strongstore::proto::VerifyMessage* Request::mutable_verify() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.verify)
  return _internal_mutable_verify();
}
inline void Request::set_allocated_verify(::strongstore::proto::VerifyMessage* verify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete verify_;
  }
  if (verify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(verify);
    if (message_arena != submessage_arena) {
      verify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, verify, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  verify_ = verify;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.verify)
}

// optional .strongstore.proto.VersionMessage version = 8;
inline bool Request::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || version_ != nullptr);
  return value;
}
inline bool Request::has_version() const {
  return _internal_has_version();
}
inline void Request::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::strongstore::proto::VersionMessage& Request::_internal_version() const {
  const ::strongstore::proto::VersionMessage* p = version_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::VersionMessage*>(
      &::strongstore::proto::_VersionMessage_default_instance_);
}
inline const ::strongstore::proto::VersionMessage& Request::version() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.version)
  return _internal_version();
}
inline void Request::unsafe_arena_set_allocated_version(
    ::strongstore::proto::VersionMessage* version) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.version)
}
inline ::strongstore::proto::VersionMessage* Request::release_version() {
  _has_bits_[0] &= ~0x00000020u;
  ::strongstore::proto::VersionMessage* temp = version_;
  version_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::VersionMessage* Request::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.version)
  _has_bits_[0] &= ~0x00000020u;
  ::strongstore::proto::VersionMessage* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::strongstore::proto::VersionMessage* Request::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000020u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::VersionMessage>(GetArena());
    version_ = p;
  }
  return version_;
}
inline ::strongstore::proto::VersionMessage* Request::mutable_version() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.version)
  return _internal_mutable_version();
}
inline void Request::set_allocated_version(::strongstore::proto::VersionMessage* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.version)
}

// optional .strongstore.proto.RangeMessage range = 10;
inline bool Request::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || range_ != nullptr);
  return value;
}
inline bool Request::has_range() const {
  return _internal_has_range();
}
inline void Request::clear_range() {
  if (range_ != nullptr) range_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::strongstore::proto::RangeMessage& Request::_internal_range() const {
  const ::strongstore::proto::RangeMessage* p = range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::RangeMessage*>(
      &::strongstore::proto::_RangeMessage_default_instance_);
}
inline const ::strongstore::proto::RangeMessage& Request::range() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.range)
  return _internal_range();
}
inline void Request::unsafe_arena_set_allocated_range(
    ::strongstore::proto::RangeMessage* range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.range)
}
inline ::strongstore::proto::RangeMessage* Request::release_range() {
  _has_bits_[0] &= ~0x00000040u;
  ::strongstore::proto::RangeMessage* temp = range_;
  range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::RangeMessage* Request::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.range)
  _has_bits_[0] &= ~0x00000040u;
  ::strongstore::proto::RangeMessage* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::strongstore::proto::RangeMessage* Request::_internal_mutable_range() {
  _has_bits_[0] |= 0x00000040u;
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::RangeMessage>(GetArena());
    range_ = p;
  }
  return range_;
}
inline ::strongstore::proto::RangeMessage* Request::mutable_range() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.range)
  return _internal_mutable_range();
}
inline void Request::set_allocated_range(::strongstore::proto::RangeMessage* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.range)
}

// optional .strongstore.proto.BatchGetMessage batchget = 11;
inline bool Request::_internal_has_batchget() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || batchget_ != nullptr);
  return value;
}
inline bool Request::has_batchget() const {
  return _internal_has_batchget();
}
inline void Request::clear_batchget() {
  if (batchget_ != nullptr) batchget_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::strongstore::proto::BatchGetMessage& Request::_internal_batchget() const {
  const ::strongstore::proto::BatchGetMessage* p = batchget_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::BatchGetMessage*>(
      &::strongstore::proto::_BatchGetMessage_default_instance_);
}
inline const ::strongstore::proto::BatchGetMessage& Request::batchget() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.batchget)
  return _internal_batchget();
}
inline void Request::unsafe_arena_set_allocated_batchget(
    ::strongstore::proto::BatchGetMessage* batchget) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batchget_);
  }
  batchget_ = batchget;
  if (batchget) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.batchget)
}
inline ::strongstore::proto::BatchGetMessage* Request::release_batchget() {
  _has_bits_[0] &= ~0x00000080u;
  ::strongstore::proto::BatchGetMessage* temp = batchget_;
  batchget_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::BatchGetMessage* Request::unsafe_arena_release_batchget() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.batchget)
  _has_bits_[0] &= ~0x00000080u;
  ::strongstore::proto::BatchGetMessage* temp = batchget_;
  batchget_ = nullptr;
  return temp;
}
inline ::strongstore::proto::BatchGetMessage* Request::_internal_mutable_batchget() {
  _has_bits_[0] |= 0x00000080u;
  if (batchget_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::BatchGetMessage>(GetArena());
    batchget_ = p;
  }
  return batchget_;
}
inline ::strongstore::proto::BatchGetMessage* Request::mutable_batchget() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.batchget)
  return _internal_mutable_batchget();
}
inline void Request::set_allocated_batchget(::strongstore::proto::BatchGetMessage* batchget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete batchget_;
  }
  if (batchget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(batchget);
    if (message_arena != submessage_arena) {
      batchget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batchget, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  batchget_ = batchget;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.batchget)
}

// optional .strongstore.proto.AuditMessage audit = 12;
inline bool Request::_internal_has_audit() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || audit_ != nullptr);
  return value;
}
inline bool Request::has_audit() const {
  return _internal_has_audit();
}
inline void Request::clear_audit() {
  if (audit_ != nullptr) audit_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::strongstore::proto::AuditMessage& Request::_internal_audit() const {
  const ::strongstore::proto::AuditMessage* p = audit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::AuditMessage*>(
      &::strongstore::proto::_AuditMessage_default_instance_);
}
inline const ::strongstore::proto::AuditMessage& Request::audit() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Request.audit)
  return _internal_audit();
}
inline void Request::unsafe_arena_set_allocated_audit(
    ::strongstore::proto::AuditMessage* audit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audit_);
  }
  audit_ = audit;
  if (audit) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Request.audit)
}
inline ::strongstore::proto::AuditMessage* Request::release_audit() {
  _has_bits_[0] &= ~0x00000100u;
  ::strongstore::proto::AuditMessage* temp = audit_;
  audit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::AuditMessage* Request::unsafe_arena_release_audit() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Request.audit)
  _has_bits_[0] &= ~0x00000100u;
  ::strongstore::proto::AuditMessage* temp = audit_;
  audit_ = nullptr;
  return temp;
}
inline ::strongstore::proto::AuditMessage* Request::_internal_mutable_audit() {
  _has_bits_[0] |= 0x00000100u;
  if (audit_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::AuditMessage>(GetArena());
    audit_ = p;
  }
  return audit_;
}
inline ::strongstore::proto::AuditMessage* Request::mutable_audit() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Request.audit)
  return _internal_mutable_audit();
}
inline void Request::set_allocated_audit(::strongstore::proto::AuditMessage* audit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audit_;
  }
  if (audit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audit);
    if (message_arena != submessage_arena) {
      audit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  audit_ = audit;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Request.audit)
}

// -------------------------------------------------------------------

// LedgerDBProof

// optional bytes val = 1;
inline bool LedgerDBProof::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LedgerDBProof::has_val() const {
  return _internal_has_val();
}
inline void LedgerDBProof::clear_val() {
  val_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LedgerDBProof::val() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.val)
  return _internal_val();
}
inline void LedgerDBProof::set_val(const std::string& value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.val)
}
inline std::string* LedgerDBProof::mutable_val() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.LedgerDBProof.val)
  return _internal_mutable_val();
}
inline const std::string& LedgerDBProof::_internal_val() const {
  return val_.Get();
}
inline void LedgerDBProof::_internal_set_val(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LedgerDBProof::set_val(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  val_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.LedgerDBProof.val)
}
inline void LedgerDBProof::set_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.LedgerDBProof.val)
}
inline void LedgerDBProof::set_val(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.LedgerDBProof.val)
}
inline std::string* LedgerDBProof::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000001u;
  return val_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LedgerDBProof::release_val() {
  // @@protoc_insertion_point(field_release:strongstore.proto.LedgerDBProof.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LedgerDBProof::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  val_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), val,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.LedgerDBProof.val)
}

// optional bytes hash = 2;
inline bool LedgerDBProof::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LedgerDBProof::has_hash() const {
  return _internal_has_hash();
}
inline void LedgerDBProof::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LedgerDBProof::hash() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.hash)
  return _internal_hash();
}
inline void LedgerDBProof::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.hash)
}
inline std::string* LedgerDBProof::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.LedgerDBProof.hash)
  return _internal_mutable_hash();
}
inline const std::string& LedgerDBProof::_internal_hash() const {
  return hash_.Get();
}
inline void LedgerDBProof::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LedgerDBProof::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.LedgerDBProof.hash)
}
inline void LedgerDBProof::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.LedgerDBProof.hash)
}
inline void LedgerDBProof::set_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.LedgerDBProof.hash)
}
inline std::string* LedgerDBProof::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000002u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LedgerDBProof::release_hash() {
  // @@protoc_insertion_point(field_release:strongstore.proto.LedgerDBProof.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LedgerDBProof::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.LedgerDBProof.hash)
}

// repeated bytes proof = 3;
inline int LedgerDBProof::_internal_proof_size() const {
  return proof_.size();
}
inline int LedgerDBProof::proof_size() const {
  return _internal_proof_size();
}
inline void LedgerDBProof::clear_proof() {
  proof_.Clear();
}
inline std::string* LedgerDBProof::add_proof() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.LedgerDBProof.proof)
  return _internal_add_proof();
}
inline const std::string& LedgerDBProof::_internal_proof(int index) const {
  return proof_.Get(index);
}
inline const std::string& LedgerDBProof::proof(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.proof)
  return _internal_proof(index);
}
inline std::string* LedgerDBProof::mutable_proof(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.LedgerDBProof.proof)
  return proof_.Mutable(index);
}
inline void LedgerDBProof::set_proof(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.proof)
  proof_.Mutable(index)->assign(value);
}
inline void LedgerDBProof::set_proof(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.proof)
  proof_.Mutable(index)->assign(std::move(value));
}
inline void LedgerDBProof::set_proof(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.LedgerDBProof.proof)
}
inline void LedgerDBProof::set_proof(int index, const void* value, size_t size) {
  proof_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.LedgerDBProof.proof)
}
inline std::string* LedgerDBProof::_internal_add_proof() {
  return proof_.Add();
}
inline void LedgerDBProof::add_proof(const std::string& value) {
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.proof)
}
inline void LedgerDBProof::add_proof(std::string&& value) {
  proof_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.proof)
}
inline void LedgerDBProof::add_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.LedgerDBProof.proof)
}
inline void LedgerDBProof::add_proof(const void* value, size_t size) {
  proof_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.LedgerDBProof.proof)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LedgerDBProof::proof() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.LedgerDBProof.proof)
  return proof_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LedgerDBProof::mutable_proof() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.LedgerDBProof.proof)
  return &proof_;
}

// repeated int32 mt_pos = 4;
inline int LedgerDBProof::_internal_mt_pos_size() const {
  return mt_pos_.size();
}
inline int LedgerDBProof::mt_pos_size() const {
  return _internal_mt_pos_size();
}
inline void LedgerDBProof::clear_mt_pos() {
  mt_pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LedgerDBProof::_internal_mt_pos(int index) const {
  return mt_pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LedgerDBProof::mt_pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.mt_pos)
  return _internal_mt_pos(index);
}
inline void LedgerDBProof::set_mt_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  mt_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.mt_pos)
}
inline void LedgerDBProof::_internal_add_mt_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  mt_pos_.Add(value);
}
inline void LedgerDBProof::add_mt_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_mt_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.mt_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LedgerDBProof::_internal_mt_pos() const {
  return mt_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LedgerDBProof::mt_pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.LedgerDBProof.mt_pos)
  return _internal_mt_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LedgerDBProof::_internal_mutable_mt_pos() {
  return &mt_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LedgerDBProof::mutable_mt_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.LedgerDBProof.mt_pos)
  return _internal_mutable_mt_pos();
}

// optional bytes mptvalue = 5;
inline bool LedgerDBProof::_internal_has_mptvalue() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LedgerDBProof::has_mptvalue() const {
  return _internal_has_mptvalue();
}
inline void LedgerDBProof::clear_mptvalue() {
  mptvalue_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LedgerDBProof::mptvalue() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.mptvalue)
  return _internal_mptvalue();
}
inline void LedgerDBProof::set_mptvalue(const std::string& value) {
  _internal_set_mptvalue(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.mptvalue)
}
inline std::string* LedgerDBProof::mutable_mptvalue() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.LedgerDBProof.mptvalue)
  return _internal_mutable_mptvalue();
}
inline const std::string& LedgerDBProof::_internal_mptvalue() const {
  return mptvalue_.Get();
}
inline void LedgerDBProof::_internal_set_mptvalue(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  mptvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LedgerDBProof::set_mptvalue(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  mptvalue_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.LedgerDBProof.mptvalue)
}
inline void LedgerDBProof::set_mptvalue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  mptvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.LedgerDBProof.mptvalue)
}
inline void LedgerDBProof::set_mptvalue(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  mptvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.LedgerDBProof.mptvalue)
}
inline std::string* LedgerDBProof::_internal_mutable_mptvalue() {
  _has_bits_[0] |= 0x00000004u;
  return mptvalue_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LedgerDBProof::release_mptvalue() {
  // @@protoc_insertion_point(field_release:strongstore.proto.LedgerDBProof.mptvalue)
  if (!_internal_has_mptvalue()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return mptvalue_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LedgerDBProof::set_allocated_mptvalue(std::string* mptvalue) {
  if (mptvalue != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mptvalue_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mptvalue,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.LedgerDBProof.mptvalue)
}

// repeated bytes mpt_chunks = 6;
inline int LedgerDBProof::_internal_mpt_chunks_size() const {
  return mpt_chunks_.size();
}
inline int LedgerDBProof::mpt_chunks_size() const {
  return _internal_mpt_chunks_size();
}
inline void LedgerDBProof::clear_mpt_chunks() {
  mpt_chunks_.Clear();
}
inline std::string* LedgerDBProof::add_mpt_chunks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.LedgerDBProof.mpt_chunks)
  return _internal_add_mpt_chunks();
}
inline const std::string& LedgerDBProof::_internal_mpt_chunks(int index) const {
  return mpt_chunks_.Get(index);
}
inline const std::string& LedgerDBProof::mpt_chunks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.mpt_chunks)
  return _internal_mpt_chunks(index);
}
inline std::string* LedgerDBProof::mutable_mpt_chunks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.LedgerDBProof.mpt_chunks)
  return mpt_chunks_.Mutable(index);
}
inline void LedgerDBProof::set_mpt_chunks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.mpt_chunks)
  mpt_chunks_.Mutable(index)->assign(value);
}
inline void LedgerDBProof::set_mpt_chunks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.mpt_chunks)
  mpt_chunks_.Mutable(index)->assign(std::move(value));
}
inline void LedgerDBProof::set_mpt_chunks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mpt_chunks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline void LedgerDBProof::set_mpt_chunks(int index, const void* value, size_t size) {
  mpt_chunks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline std::string* LedgerDBProof::_internal_add_mpt_chunks() {
  return mpt_chunks_.Add();
}
inline void LedgerDBProof::add_mpt_chunks(const std::string& value) {
  mpt_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline void LedgerDBProof::add_mpt_chunks(std::string&& value) {
  mpt_chunks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline void LedgerDBProof::add_mpt_chunks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mpt_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline void LedgerDBProof::add_mpt_chunks(const void* value, size_t size) {
  mpt_chunks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.LedgerDBProof.mpt_chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LedgerDBProof::mpt_chunks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.LedgerDBProof.mpt_chunks)
  return mpt_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LedgerDBProof::mutable_mpt_chunks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.LedgerDBProof.mpt_chunks)
  return &mpt_chunks_;
}

// repeated int32 mpt_pos = 7;
inline int LedgerDBProof::_internal_mpt_pos_size() const {
  return mpt_pos_.size();
}
inline int LedgerDBProof::mpt_pos_size() const {
  return _internal_mpt_pos_size();
}
inline void LedgerDBProof::clear_mpt_pos() {
  mpt_pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LedgerDBProof::_internal_mpt_pos(int index) const {
  return mpt_pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LedgerDBProof::mpt_pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.LedgerDBProof.mpt_pos)
  return _internal_mpt_pos(index);
}
inline void LedgerDBProof::set_mpt_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  mpt_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.LedgerDBProof.mpt_pos)
}
inline void LedgerDBProof::_internal_add_mpt_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  mpt_pos_.Add(value);
}
inline void LedgerDBProof::add_mpt_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_mpt_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.LedgerDBProof.mpt_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LedgerDBProof::_internal_mpt_pos() const {
  return mpt_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LedgerDBProof::mpt_pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.LedgerDBProof.mpt_pos)
  return _internal_mpt_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LedgerDBProof::_internal_mutable_mpt_pos() {
  return &mpt_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LedgerDBProof::mutable_mpt_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.LedgerDBProof.mpt_pos)
  return _internal_mutable_mpt_pos();
}

// -------------------------------------------------------------------

// QLDBProof

// optional bytes key = 1;
inline bool QLDBProof::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QLDBProof::has_key() const {
  return _internal_has_key();
}
inline void QLDBProof::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QLDBProof::key() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.key)
  return _internal_key();
}
inline void QLDBProof::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.key)
}
inline std::string* QLDBProof::mutable_key() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.QLDBProof.key)
  return _internal_mutable_key();
}
inline const std::string& QLDBProof::_internal_key() const {
  return key_.Get();
}
inline void QLDBProof::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void QLDBProof::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.QLDBProof.key)
}
inline void QLDBProof::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.QLDBProof.key)
}
inline void QLDBProof::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.QLDBProof.key)
}
inline std::string* QLDBProof::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* QLDBProof::release_key() {
  // @@protoc_insertion_point(field_release:strongstore.proto.QLDBProof.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void QLDBProof::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.QLDBProof.key)
}

// optional bytes value = 2;
inline bool QLDBProof::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QLDBProof::has_value() const {
  return _internal_has_value();
}
inline void QLDBProof::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QLDBProof::value() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.value)
  return _internal_value();
}
inline void QLDBProof::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.value)
}
inline std::string* QLDBProof::mutable_value() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.QLDBProof.value)
  return _internal_mutable_value();
}
inline const std::string& QLDBProof::_internal_value() const {
  return value_.Get();
}
inline void QLDBProof::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void QLDBProof::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.QLDBProof.value)
}
inline void QLDBProof::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.QLDBProof.value)
}
inline void QLDBProof::set_value(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.QLDBProof.value)
}
inline std::string* QLDBProof::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* QLDBProof::release_value() {
  // @@protoc_insertion_point(field_release:strongstore.proto.QLDBProof.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void QLDBProof::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.QLDBProof.value)
}

// optional uint64 blockno = 3;
inline bool QLDBProof::_internal_has_blockno() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QLDBProof::has_blockno() const {
  return _internal_has_blockno();
}
inline void QLDBProof::clear_blockno() {
  blockno_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::_internal_blockno() const {
  return blockno_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::blockno() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.blockno)
  return _internal_blockno();
}
inline void QLDBProof::_internal_set_blockno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  blockno_ = value;
}
inline void QLDBProof::set_blockno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blockno(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.blockno)
}

// optional uint64 doc_seq = 4;
inline bool QLDBProof::_internal_has_doc_seq() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QLDBProof::has_doc_seq() const {
  return _internal_has_doc_seq();
}
inline void QLDBProof::clear_doc_seq() {
  doc_seq_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::_internal_doc_seq() const {
  return doc_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::doc_seq() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.doc_seq)
  return _internal_doc_seq();
}
inline void QLDBProof::_internal_set_doc_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  doc_seq_ = value;
}
inline void QLDBProof::set_doc_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_doc_seq(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.doc_seq)
}

// optional uint64 version = 5;
inline bool QLDBProof::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QLDBProof::has_version() const {
  return _internal_has_version();
}
inline void QLDBProof::clear_version() {
  version_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::version() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.version)
  return _internal_version();
}
inline void QLDBProof::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void QLDBProof::set_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.version)
}

// optional uint64 time = 6;
inline bool QLDBProof::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QLDBProof::has_time() const {
  return _internal_has_time();
}
inline void QLDBProof::clear_time() {
  time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QLDBProof::time() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.time)
  return _internal_time();
}
inline void QLDBProof::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  time_ = value;
}
inline void QLDBProof::set_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.time)
}

// repeated bytes hashes = 7;
inline int QLDBProof::_internal_hashes_size() const {
  return hashes_.size();
}
inline int QLDBProof::hashes_size() const {
  return _internal_hashes_size();
}
inline void QLDBProof::clear_hashes() {
  hashes_.Clear();
}
inline std::string* QLDBProof::add_hashes() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.QLDBProof.hashes)
  return _internal_add_hashes();
}
inline const std::string& QLDBProof::_internal_hashes(int index) const {
  return hashes_.Get(index);
}
inline const std::string& QLDBProof::hashes(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.hashes)
  return _internal_hashes(index);
}
inline std::string* QLDBProof::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.QLDBProof.hashes)
  return hashes_.Mutable(index);
}
inline void QLDBProof::set_hashes(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.hashes)
  hashes_.Mutable(index)->assign(value);
}
inline void QLDBProof::set_hashes(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.hashes)
  hashes_.Mutable(index)->assign(std::move(value));
}
inline void QLDBProof::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.QLDBProof.hashes)
}
inline void QLDBProof::set_hashes(int index, const void* value, size_t size) {
  hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.QLDBProof.hashes)
}
inline std::string* QLDBProof::_internal_add_hashes() {
  return hashes_.Add();
}
inline void QLDBProof::add_hashes(const std::string& value) {
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.QLDBProof.hashes)
}
inline void QLDBProof::add_hashes(std::string&& value) {
  hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.QLDBProof.hashes)
}
inline void QLDBProof::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.QLDBProof.hashes)
}
inline void QLDBProof::add_hashes(const void* value, size_t size) {
  hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.QLDBProof.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QLDBProof::hashes() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.QLDBProof.hashes)
  return hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QLDBProof::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.QLDBProof.hashes)
  return &hashes_;
}

// repeated int32 pos = 8;
inline int QLDBProof::_internal_pos_size() const {
  return pos_.size();
}
inline int QLDBProof::pos_size() const {
  return _internal_pos_size();
}
inline void QLDBProof::clear_pos() {
  pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QLDBProof::_internal_pos(int index) const {
  return pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QLDBProof::pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.QLDBProof.pos)
  return _internal_pos(index);
}
inline void QLDBProof::set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.QLDBProof.pos)
}
inline void QLDBProof::_internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Add(value);
}
inline void QLDBProof::add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.QLDBProof.pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
QLDBProof::_internal_pos() const {
  return pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
QLDBProof::pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.QLDBProof.pos)
  return _internal_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
QLDBProof::_internal_mutable_pos() {
  return &pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
QLDBProof::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.QLDBProof.pos)
  return _internal_mutable_pos();
}

// -------------------------------------------------------------------

// MTProof

// optional bytes digest = 1;
inline bool MTProof::_internal_has_digest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MTProof::has_digest() const {
  return _internal_has_digest();
}
inline void MTProof::clear_digest() {
  digest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MTProof::digest() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MTProof.digest)
  return _internal_digest();
}
inline void MTProof::set_digest(const std::string& value) {
  _internal_set_digest(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.MTProof.digest)
}
inline std::string* MTProof::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.MTProof.digest)
  return _internal_mutable_digest();
}
inline const std::string& MTProof::_internal_digest() const {
  return digest_.Get();
}
inline void MTProof::_internal_set_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MTProof::set_digest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.MTProof.digest)
}
inline void MTProof::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.MTProof.digest)
}
inline void MTProof::set_digest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.MTProof.digest)
}
inline std::string* MTProof::_internal_mutable_digest() {
  _has_bits_[0] |= 0x00000001u;
  return digest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MTProof::release_digest() {
  // @@protoc_insertion_point(field_release:strongstore.proto.MTProof.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MTProof::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.MTProof.digest)
}

// optional bytes value = 2;
inline bool MTProof::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MTProof::has_value() const {
  return _internal_has_value();
}
inline void MTProof::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MTProof::value() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MTProof.value)
  return _internal_value();
}
inline void MTProof::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.MTProof.value)
}
inline std::string* MTProof::mutable_value() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.MTProof.value)
  return _internal_mutable_value();
}
inline const std::string& MTProof::_internal_value() const {
  return value_.Get();
}
inline void MTProof::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MTProof::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.MTProof.value)
}
inline void MTProof::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.MTProof.value)
}
inline void MTProof::set_value(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.MTProof.value)
}
inline std::string* MTProof::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MTProof::release_value() {
  // @@protoc_insertion_point(field_release:strongstore.proto.MTProof.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MTProof::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.MTProof.value)
}

// repeated bytes proof = 3;
inline int MTProof::_internal_proof_size() const {
  return proof_.size();
}
inline int MTProof::proof_size() const {
  return _internal_proof_size();
}
inline void MTProof::clear_proof() {
  proof_.Clear();
}
inline std::string* MTProof::add_proof() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.MTProof.proof)
  return _internal_add_proof();
}
inline const std::string& MTProof::_internal_proof(int index) const {
  return proof_.Get(index);
}
inline const std::string& MTProof::proof(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MTProof.proof)
  return _internal_proof(index);
}
inline std::string* MTProof::mutable_proof(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.MTProof.proof)
  return proof_.Mutable(index);
}
inline void MTProof::set_proof(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.MTProof.proof)
  proof_.Mutable(index)->assign(value);
}
inline void MTProof::set_proof(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.MTProof.proof)
  proof_.Mutable(index)->assign(std::move(value));
}
inline void MTProof::set_proof(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.MTProof.proof)
}
inline void MTProof::set_proof(int index, const void* value, size_t size) {
  proof_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.MTProof.proof)
}
inline std::string* MTProof::_internal_add_proof() {
  return proof_.Add();
}
inline void MTProof::add_proof(const std::string& value) {
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.MTProof.proof)
}
inline void MTProof::add_proof(std::string&& value) {
  proof_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.MTProof.proof)
}
inline void MTProof::add_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.MTProof.proof)
}
inline void MTProof::add_proof(const void* value, size_t size) {
  proof_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.MTProof.proof)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MTProof::proof() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.MTProof.proof)
  return proof_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MTProof::mutable_proof() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.MTProof.proof)
  return &proof_;
}

// repeated int32 pos = 4;
inline int MTProof::_internal_pos_size() const {
  return pos_.size();
}
inline int MTProof::pos_size() const {
  return _internal_pos_size();
}
inline void MTProof::clear_pos() {
  pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MTProof::_internal_pos(int index) const {
  return pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MTProof::pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MTProof.pos)
  return _internal_pos(index);
}
inline void MTProof::set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.MTProof.pos)
}
inline void MTProof::_internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Add(value);
}
inline void MTProof::add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.MTProof.pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MTProof::_internal_pos() const {
  return pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MTProof::pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.MTProof.pos)
  return _internal_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MTProof::_internal_mutable_pos() {
  return &pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MTProof::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.MTProof.pos)
  return _internal_mutable_pos();
}

// -------------------------------------------------------------------

// MPTProof

// optional bytes value = 1;
inline bool MPTProof::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MPTProof::has_value() const {
  return _internal_has_value();
}
inline void MPTProof::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MPTProof::value() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MPTProof.value)
  return _internal_value();
}
inline void MPTProof::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.MPTProof.value)
}
inline std::string* MPTProof::mutable_value() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.MPTProof.value)
  return _internal_mutable_value();
}
inline const std::string& MPTProof::_internal_value() const {
  return value_.Get();
}
inline void MPTProof::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MPTProof::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.MPTProof.value)
}
inline void MPTProof::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.MPTProof.value)
}
inline void MPTProof::set_value(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.MPTProof.value)
}
inline std::string* MPTProof::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MPTProof::release_value() {
  // @@protoc_insertion_point(field_release:strongstore.proto.MPTProof.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MPTProof::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.MPTProof.value)
}

// repeated bytes chunks = 2;
inline int MPTProof::_internal_chunks_size() const {
  return chunks_.size();
}
inline int MPTProof::chunks_size() const {
  return _internal_chunks_size();
}
inline void MPTProof::clear_chunks() {
  chunks_.Clear();
}
inline std::string* MPTProof::add_chunks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.MPTProof.chunks)
  return _internal_add_chunks();
}
inline const std::string& MPTProof::_internal_chunks(int index) const {
  return chunks_.Get(index);
}
inline const std::string& MPTProof::chunks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MPTProof.chunks)
  return _internal_chunks(index);
}
inline std::string* MPTProof::mutable_chunks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.MPTProof.chunks)
  return chunks_.Mutable(index);
}
inline void MPTProof::set_chunks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.MPTProof.chunks)
  chunks_.Mutable(index)->assign(value);
}
inline void MPTProof::set_chunks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.MPTProof.chunks)
  chunks_.Mutable(index)->assign(std::move(value));
}
inline void MPTProof::set_chunks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chunks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.MPTProof.chunks)
}
inline void MPTProof::set_chunks(int index, const void* value, size_t size) {
  chunks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.MPTProof.chunks)
}
inline std::string* MPTProof::_internal_add_chunks() {
  return chunks_.Add();
}
inline void MPTProof::add_chunks(const std::string& value) {
  chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.MPTProof.chunks)
}
inline void MPTProof::add_chunks(std::string&& value) {
  chunks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.MPTProof.chunks)
}
inline void MPTProof::add_chunks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.MPTProof.chunks)
}
inline void MPTProof::add_chunks(const void* value, size_t size) {
  chunks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.MPTProof.chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MPTProof::chunks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.MPTProof.chunks)
  return chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MPTProof::mutable_chunks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.MPTProof.chunks)
  return &chunks_;
}

// repeated int32 pos = 3;
inline int MPTProof::_internal_pos_size() const {
  return pos_.size();
}
inline int MPTProof::pos_size() const {
  return _internal_pos_size();
}
inline void MPTProof::clear_pos() {
  pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MPTProof::_internal_pos(int index) const {
  return pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MPTProof::pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.MPTProof.pos)
  return _internal_pos(index);
}
inline void MPTProof::set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.MPTProof.pos)
}
inline void MPTProof::_internal_add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Add(value);
}
inline void MPTProof::add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.MPTProof.pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MPTProof::_internal_pos() const {
  return pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MPTProof::pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.MPTProof.pos)
  return _internal_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MPTProof::_internal_mutable_pos() {
  return &pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MPTProof::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.MPTProof.pos)
  return _internal_mutable_pos();
}

// -------------------------------------------------------------------

// SQLLedgerProof

// optional .strongstore.proto.MTProof blk_proof = 1;
inline bool SQLLedgerProof::_internal_has_blk_proof() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || blk_proof_ != nullptr);
  return value;
}
inline bool SQLLedgerProof::has_blk_proof() const {
  return _internal_has_blk_proof();
}
inline void SQLLedgerProof::clear_blk_proof() {
  if (blk_proof_ != nullptr) blk_proof_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::strongstore::proto::MTProof& SQLLedgerProof::_internal_blk_proof() const {
  const ::strongstore::proto::MTProof* p = blk_proof_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::MTProof*>(
      &::strongstore::proto::_MTProof_default_instance_);
}
inline const ::strongstore::proto::MTProof& SQLLedgerProof::blk_proof() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.SQLLedgerProof.blk_proof)
  return _internal_blk_proof();
}
inline void SQLLedgerProof::unsafe_arena_set_allocated_blk_proof(
    ::strongstore::proto::MTProof* blk_proof) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blk_proof_);
  }
  blk_proof_ = blk_proof;
  if (blk_proof) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.SQLLedgerProof.blk_proof)
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::release_blk_proof() {
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::MTProof* temp = blk_proof_;
  blk_proof_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::unsafe_arena_release_blk_proof() {
  // @@protoc_insertion_point(field_release:strongstore.proto.SQLLedgerProof.blk_proof)
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::MTProof* temp = blk_proof_;
  blk_proof_ = nullptr;
  return temp;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::_internal_mutable_blk_proof() {
  _has_bits_[0] |= 0x00000002u;
  if (blk_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::MTProof>(GetArena());
    blk_proof_ = p;
  }
  return blk_proof_;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::mutable_blk_proof() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.SQLLedgerProof.blk_proof)
  return _internal_mutable_blk_proof();
}
inline void SQLLedgerProof::set_allocated_blk_proof(::strongstore::proto::MTProof* blk_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete blk_proof_;
  }
  if (blk_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(blk_proof);
    if (message_arena != submessage_arena) {
      blk_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blk_proof, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blk_proof_ = blk_proof;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.SQLLedgerProof.blk_proof)
}

// optional .strongstore.proto.MTProof txn_proof = 2;
inline bool SQLLedgerProof::_internal_has_txn_proof() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || txn_proof_ != nullptr);
  return value;
}
inline bool SQLLedgerProof::has_txn_proof() const {
  return _internal_has_txn_proof();
}
inline void SQLLedgerProof::clear_txn_proof() {
  if (txn_proof_ != nullptr) txn_proof_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::strongstore::proto::MTProof& SQLLedgerProof::_internal_txn_proof() const {
  const ::strongstore::proto::MTProof* p = txn_proof_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::MTProof*>(
      &::strongstore::proto::_MTProof_default_instance_);
}
inline const ::strongstore::proto::MTProof& SQLLedgerProof::txn_proof() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.SQLLedgerProof.txn_proof)
  return _internal_txn_proof();
}
inline void SQLLedgerProof::unsafe_arena_set_allocated_txn_proof(
    ::strongstore::proto::MTProof* txn_proof) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_proof_);
  }
  txn_proof_ = txn_proof;
  if (txn_proof) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.SQLLedgerProof.txn_proof)
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::release_txn_proof() {
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::MTProof* temp = txn_proof_;
  txn_proof_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::unsafe_arena_release_txn_proof() {
  // @@protoc_insertion_point(field_release:strongstore.proto.SQLLedgerProof.txn_proof)
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::MTProof* temp = txn_proof_;
  txn_proof_ = nullptr;
  return temp;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::_internal_mutable_txn_proof() {
  _has_bits_[0] |= 0x00000004u;
  if (txn_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::MTProof>(GetArena());
    txn_proof_ = p;
  }
  return txn_proof_;
}
inline ::strongstore::proto::MTProof* SQLLedgerProof::mutable_txn_proof() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.SQLLedgerProof.txn_proof)
  return _internal_mutable_txn_proof();
}
inline void SQLLedgerProof::set_allocated_txn_proof(::strongstore::proto::MTProof* txn_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete txn_proof_;
  }
  if (txn_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(txn_proof);
    if (message_arena != submessage_arena) {
      txn_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_proof, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  txn_proof_ = txn_proof;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.SQLLedgerProof.txn_proof)
}

// repeated bytes blocks = 3;
inline int SQLLedgerProof::_internal_blocks_size() const {
  return blocks_.size();
}
inline int SQLLedgerProof::blocks_size() const {
  return _internal_blocks_size();
}
inline void SQLLedgerProof::clear_blocks() {
  blocks_.Clear();
}
inline std::string* SQLLedgerProof::add_blocks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.SQLLedgerProof.blocks)
  return _internal_add_blocks();
}
inline const std::string& SQLLedgerProof::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const std::string& SQLLedgerProof::blocks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.SQLLedgerProof.blocks)
  return _internal_blocks(index);
}
inline std::string* SQLLedgerProof::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.SQLLedgerProof.blocks)
  return blocks_.Mutable(index);
}
inline void SQLLedgerProof::set_blocks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.SQLLedgerProof.blocks)
  blocks_.Mutable(index)->assign(value);
}
inline void SQLLedgerProof::set_blocks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.SQLLedgerProof.blocks)
  blocks_.Mutable(index)->assign(std::move(value));
}
inline void SQLLedgerProof::set_blocks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.SQLLedgerProof.blocks)
}
inline void SQLLedgerProof::set_blocks(int index, const void* value, size_t size) {
  blocks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.SQLLedgerProof.blocks)
}
inline std::string* SQLLedgerProof::_internal_add_blocks() {
  return blocks_.Add();
}
inline void SQLLedgerProof::add_blocks(const std::string& value) {
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.SQLLedgerProof.blocks)
}
inline void SQLLedgerProof::add_blocks(std::string&& value) {
  blocks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.SQLLedgerProof.blocks)
}
inline void SQLLedgerProof::add_blocks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.SQLLedgerProof.blocks)
}
inline void SQLLedgerProof::add_blocks(const void* value, size_t size) {
  blocks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.SQLLedgerProof.blocks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SQLLedgerProof::blocks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.SQLLedgerProof.blocks)
  return blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SQLLedgerProof::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.SQLLedgerProof.blocks)
  return &blocks_;
}

// optional bytes digest = 4;
inline bool SQLLedgerProof::_internal_has_digest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SQLLedgerProof::has_digest() const {
  return _internal_has_digest();
}
inline void SQLLedgerProof::clear_digest() {
  digest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SQLLedgerProof::digest() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.SQLLedgerProof.digest)
  return _internal_digest();
}
inline void SQLLedgerProof::set_digest(const std::string& value) {
  _internal_set_digest(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.SQLLedgerProof.digest)
}
inline std::string* SQLLedgerProof::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.SQLLedgerProof.digest)
  return _internal_mutable_digest();
}
inline const std::string& SQLLedgerProof::_internal_digest() const {
  return digest_.Get();
}
inline void SQLLedgerProof::_internal_set_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SQLLedgerProof::set_digest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.SQLLedgerProof.digest)
}
inline void SQLLedgerProof::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.SQLLedgerProof.digest)
}
inline void SQLLedgerProof::set_digest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.SQLLedgerProof.digest)
}
inline std::string* SQLLedgerProof::_internal_mutable_digest() {
  _has_bits_[0] |= 0x00000001u;
  return digest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SQLLedgerProof::release_digest() {
  // @@protoc_insertion_point(field_release:strongstore.proto.SQLLedgerProof.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SQLLedgerProof::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.SQLLedgerProof.digest)
}

// -------------------------------------------------------------------

// Range

// optional int32 start = 1;
inline bool Range::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Range::has_start() const {
  return _internal_has_start();
}
inline void Range::clear_start() {
  start_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Range::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Range::start() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Range.start)
  return _internal_start();
}
inline void Range::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  start_ = value;
}
inline void Range::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Range.start)
}

// optional int32 end = 2;
inline bool Range::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Range::has_end() const {
  return _internal_has_end();
}
inline void Range::clear_end() {
  end_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Range::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Range::end() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Range.end)
  return _internal_end();
}
inline void Range::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  end_ = value;
}
inline void Range::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Range.end)
}

// -------------------------------------------------------------------

// USTOREProof

// repeated bytes value = 1;
inline int USTOREProof::_internal_value_size() const {
  return value_.size();
}
inline int USTOREProof::value_size() const {
  return _internal_value_size();
}
inline void USTOREProof::clear_value() {
  value_.Clear();
}
inline std::string* USTOREProof::add_value() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.USTOREProof.value)
  return _internal_add_value();
}
inline const std::string& USTOREProof::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& USTOREProof::value(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.value)
  return _internal_value(index);
}
inline std::string* USTOREProof::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.USTOREProof.value)
  return value_.Mutable(index);
}
inline void USTOREProof::set_value(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.value)
  value_.Mutable(index)->assign(value);
}
inline void USTOREProof::set_value(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.value)
  value_.Mutable(index)->assign(std::move(value));
}
inline void USTOREProof::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.USTOREProof.value)
}
inline void USTOREProof::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.USTOREProof.value)
}
inline std::string* USTOREProof::_internal_add_value() {
  return value_.Add();
}
inline void USTOREProof::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.value)
}
inline void USTOREProof::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.value)
}
inline void USTOREProof::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.USTOREProof.value)
}
inline void USTOREProof::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.USTOREProof.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
USTOREProof::value() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
USTOREProof::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.value)
  return &value_;
}

// repeated bytes list_chunks = 2;
inline int USTOREProof::_internal_list_chunks_size() const {
  return list_chunks_.size();
}
inline int USTOREProof::list_chunks_size() const {
  return _internal_list_chunks_size();
}
inline void USTOREProof::clear_list_chunks() {
  list_chunks_.Clear();
}
inline std::string* USTOREProof::add_list_chunks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.USTOREProof.list_chunks)
  return _internal_add_list_chunks();
}
inline const std::string& USTOREProof::_internal_list_chunks(int index) const {
  return list_chunks_.Get(index);
}
inline const std::string& USTOREProof::list_chunks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.list_chunks)
  return _internal_list_chunks(index);
}
inline std::string* USTOREProof::mutable_list_chunks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.USTOREProof.list_chunks)
  return list_chunks_.Mutable(index);
}
inline void USTOREProof::set_list_chunks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.list_chunks)
  list_chunks_.Mutable(index)->assign(value);
}
inline void USTOREProof::set_list_chunks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.list_chunks)
  list_chunks_.Mutable(index)->assign(std::move(value));
}
inline void USTOREProof::set_list_chunks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  list_chunks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.USTOREProof.list_chunks)
}
inline void USTOREProof::set_list_chunks(int index, const void* value, size_t size) {
  list_chunks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.USTOREProof.list_chunks)
}
inline std::string* USTOREProof::_internal_add_list_chunks() {
  return list_chunks_.Add();
}
inline void USTOREProof::add_list_chunks(const std::string& value) {
  list_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.list_chunks)
}
inline void USTOREProof::add_list_chunks(std::string&& value) {
  list_chunks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.list_chunks)
}
inline void USTOREProof::add_list_chunks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  list_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.USTOREProof.list_chunks)
}
inline void USTOREProof::add_list_chunks(const void* value, size_t size) {
  list_chunks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.USTOREProof.list_chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
USTOREProof::list_chunks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.list_chunks)
  return list_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
USTOREProof::mutable_list_chunks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.list_chunks)
  return &list_chunks_;
}

// repeated int32 list_pos = 3;
inline int USTOREProof::_internal_list_pos_size() const {
  return list_pos_.size();
}
inline int USTOREProof::list_pos_size() const {
  return _internal_list_pos_size();
}
inline void USTOREProof::clear_list_pos() {
  list_pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 USTOREProof::_internal_list_pos(int index) const {
  return list_pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 USTOREProof::list_pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.list_pos)
  return _internal_list_pos(index);
}
inline void USTOREProof::set_list_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  list_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.list_pos)
}
inline void USTOREProof::_internal_add_list_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  list_pos_.Add(value);
}
inline void USTOREProof::add_list_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_list_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.list_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
USTOREProof::_internal_list_pos() const {
  return list_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
USTOREProof::list_pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.list_pos)
  return _internal_list_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
USTOREProof::_internal_mutable_list_pos() {
  return &list_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
USTOREProof::mutable_list_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.list_pos)
  return _internal_mutable_list_pos();
}

// repeated bytes map_chunks = 4;
inline int USTOREProof::_internal_map_chunks_size() const {
  return map_chunks_.size();
}
inline int USTOREProof::map_chunks_size() const {
  return _internal_map_chunks_size();
}
inline void USTOREProof::clear_map_chunks() {
  map_chunks_.Clear();
}
inline std::string* USTOREProof::add_map_chunks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.USTOREProof.map_chunks)
  return _internal_add_map_chunks();
}
inline const std::string& USTOREProof::_internal_map_chunks(int index) const {
  return map_chunks_.Get(index);
}
inline const std::string& USTOREProof::map_chunks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.map_chunks)
  return _internal_map_chunks(index);
}
inline std::string* USTOREProof::mutable_map_chunks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.USTOREProof.map_chunks)
  return map_chunks_.Mutable(index);
}
inline void USTOREProof::set_map_chunks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.map_chunks)
  map_chunks_.Mutable(index)->assign(value);
}
inline void USTOREProof::set_map_chunks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.map_chunks)
  map_chunks_.Mutable(index)->assign(std::move(value));
}
inline void USTOREProof::set_map_chunks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  map_chunks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.USTOREProof.map_chunks)
}
inline void USTOREProof::set_map_chunks(int index, const void* value, size_t size) {
  map_chunks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.USTOREProof.map_chunks)
}
inline std::string* USTOREProof::_internal_add_map_chunks() {
  return map_chunks_.Add();
}
inline void USTOREProof::add_map_chunks(const std::string& value) {
  map_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.map_chunks)
}
inline void USTOREProof::add_map_chunks(std::string&& value) {
  map_chunks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.map_chunks)
}
inline void USTOREProof::add_map_chunks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  map_chunks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.USTOREProof.map_chunks)
}
inline void USTOREProof::add_map_chunks(const void* value, size_t size) {
  map_chunks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.USTOREProof.map_chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
USTOREProof::map_chunks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.map_chunks)
  return map_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
USTOREProof::mutable_map_chunks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.map_chunks)
  return &map_chunks_;
}

// repeated int32 map_pos = 5;
inline int USTOREProof::_internal_map_pos_size() const {
  return map_pos_.size();
}
inline int USTOREProof::map_pos_size() const {
  return _internal_map_pos_size();
}
inline void USTOREProof::clear_map_pos() {
  map_pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 USTOREProof::_internal_map_pos(int index) const {
  return map_pos_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 USTOREProof::map_pos(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.map_pos)
  return _internal_map_pos(index);
}
inline void USTOREProof::set_map_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  map_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.map_pos)
}
inline void USTOREProof::_internal_add_map_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  map_pos_.Add(value);
}
inline void USTOREProof::add_map_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_map_pos(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.map_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
USTOREProof::_internal_map_pos() const {
  return map_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
USTOREProof::map_pos() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.map_pos)
  return _internal_map_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
USTOREProof::_internal_mutable_map_pos() {
  return &map_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
USTOREProof::mutable_map_pos() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.map_pos)
  return _internal_mutable_map_pos();
}

// repeated bytes keys = 6;
inline int USTOREProof::_internal_keys_size() const {
  return keys_.size();
}
inline int USTOREProof::keys_size() const {
  return _internal_keys_size();
}
inline void USTOREProof::clear_keys() {
  keys_.Clear();
}
inline std::string* USTOREProof::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.USTOREProof.keys)
  return _internal_add_keys();
}
inline const std::string& USTOREProof::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& USTOREProof::keys(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.keys)
  return _internal_keys(index);
}
inline std::string* USTOREProof::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.USTOREProof.keys)
  return keys_.Mutable(index);
}
inline void USTOREProof::set_keys(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.keys)
  keys_.Mutable(index)->assign(value);
}
inline void USTOREProof::set_keys(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.USTOREProof.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
inline void USTOREProof::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.USTOREProof.keys)
}
inline void USTOREProof::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.USTOREProof.keys)
}
inline std::string* USTOREProof::_internal_add_keys() {
  return keys_.Add();
}
inline void USTOREProof::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.keys)
}
inline void USTOREProof::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.keys)
}
inline void USTOREProof::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.USTOREProof.keys)
}
inline void USTOREProof::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.USTOREProof.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
USTOREProof::keys() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
USTOREProof::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.keys)
  return &keys_;
}

// repeated .strongstore.proto.Range ranges = 7;
inline int USTOREProof::_internal_ranges_size() const {
  return ranges_.size();
}
inline int USTOREProof::ranges_size() const {
  return _internal_ranges_size();
}
inline void USTOREProof::clear_ranges() {
  ranges_.Clear();
}
inline ::strongstore::proto::Range* USTOREProof::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.USTOREProof.ranges)
  return ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Range >*
USTOREProof::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.USTOREProof.ranges)
  return &ranges_;
}
inline const ::strongstore::proto::Range& USTOREProof::_internal_ranges(int index) const {
  return ranges_.Get(index);
}
inline const ::strongstore::proto::Range& USTOREProof::ranges(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.USTOREProof.ranges)
  return _internal_ranges(index);
}
inline ::strongstore::proto::Range* USTOREProof::_internal_add_ranges() {
  return ranges_.Add();
}
inline ::strongstore::proto::Range* USTOREProof::add_ranges() {
  // @@protoc_insertion_point(field_add:strongstore.proto.USTOREProof.ranges)
  return _internal_add_ranges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Range >&
USTOREProof::ranges() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.USTOREProof.ranges)
  return ranges_;
}

// -------------------------------------------------------------------

// Reply_Digest

// optional int64 block = 1;
inline bool Reply_Digest::_internal_has_block() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reply_Digest::has_block() const {
  return _internal_has_block();
}
inline void Reply_Digest::clear_block() {
  block_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_Digest::_internal_block() const {
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_Digest::block() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.Digest.block)
  return _internal_block();
}
inline void Reply_Digest::_internal_set_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  block_ = value;
}
inline void Reply_Digest::set_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.Digest.block)
}

// optional bytes hash = 2;
inline bool Reply_Digest::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reply_Digest::has_hash() const {
  return _internal_has_hash();
}
inline void Reply_Digest::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reply_Digest::hash() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.Digest.hash)
  return _internal_hash();
}
inline void Reply_Digest::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.Digest.hash)
}
inline std::string* Reply_Digest::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.Digest.hash)
  return _internal_mutable_hash();
}
inline const std::string& Reply_Digest::_internal_hash() const {
  return hash_.Get();
}
inline void Reply_Digest::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_Digest::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.Digest.hash)
}
inline void Reply_Digest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.Digest.hash)
}
inline void Reply_Digest::set_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.Digest.hash)
}
inline std::string* Reply_Digest::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_Digest::release_hash() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.Digest.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_Digest::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.Digest.hash)
}

// optional bytes mptHash = 3;
inline bool Reply_Digest::_internal_has_mpthash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reply_Digest::has_mpthash() const {
  return _internal_has_mpthash();
}
inline void Reply_Digest::clear_mpthash() {
  mpthash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Reply_Digest::mpthash() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.Digest.mptHash)
  return _internal_mpthash();
}
inline void Reply_Digest::set_mpthash(const std::string& value) {
  _internal_set_mpthash(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.Digest.mptHash)
}
inline std::string* Reply_Digest::mutable_mpthash() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.Digest.mptHash)
  return _internal_mutable_mpthash();
}
inline const std::string& Reply_Digest::_internal_mpthash() const {
  return mpthash_.Get();
}
inline void Reply_Digest::_internal_set_mpthash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mpthash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_Digest::set_mpthash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mpthash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.Digest.mptHash)
}
inline void Reply_Digest::set_mpthash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mpthash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.Digest.mptHash)
}
inline void Reply_Digest::set_mpthash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mpthash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.Digest.mptHash)
}
inline std::string* Reply_Digest::_internal_mutable_mpthash() {
  _has_bits_[0] |= 0x00000002u;
  return mpthash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_Digest::release_mpthash() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.Digest.mptHash)
  if (!_internal_has_mpthash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mpthash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_Digest::set_allocated_mpthash(std::string* mpthash) {
  if (mpthash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mpthash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mpthash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.Digest.mptHash)
}

// -------------------------------------------------------------------

// Reply_KV

// optional string key = 1;
inline bool Reply_KV::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reply_KV::has_key() const {
  return _internal_has_key();
}
inline void Reply_KV::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reply_KV::key() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.KV.key)
  return _internal_key();
}
inline void Reply_KV::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.KV.key)
}
inline std::string* Reply_KV::mutable_key() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.KV.key)
  return _internal_mutable_key();
}
inline const std::string& Reply_KV::_internal_key() const {
  return key_.Get();
}
inline void Reply_KV::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_KV::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.KV.key)
}
inline void Reply_KV::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.KV.key)
}
inline void Reply_KV::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.KV.key)
}
inline std::string* Reply_KV::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_KV::release_key() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.KV.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_KV::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.KV.key)
}

// optional string val = 2;
inline bool Reply_KV::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reply_KV::has_val() const {
  return _internal_has_val();
}
inline void Reply_KV::clear_val() {
  val_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Reply_KV::val() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.KV.val)
  return _internal_val();
}
inline void Reply_KV::set_val(const std::string& value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.KV.val)
}
inline std::string* Reply_KV::mutable_val() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.KV.val)
  return _internal_mutable_val();
}
inline const std::string& Reply_KV::_internal_val() const {
  return val_.Get();
}
inline void Reply_KV::_internal_set_val(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_KV::set_val(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  val_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.KV.val)
}
inline void Reply_KV::set_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.KV.val)
}
inline void Reply_KV::set_val(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.KV.val)
}
inline std::string* Reply_KV::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000002u;
  return val_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_KV::release_val() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.KV.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_KV::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  val_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), val,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.KV.val)
}

// optional int64 estimate_block = 3;
inline bool Reply_KV::_internal_has_estimate_block() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reply_KV::has_estimate_block() const {
  return _internal_has_estimate_block();
}
inline void Reply_KV::clear_estimate_block() {
  estimate_block_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_KV::_internal_estimate_block() const {
  return estimate_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_KV::estimate_block() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.KV.estimate_block)
  return _internal_estimate_block();
}
inline void Reply_KV::_internal_set_estimate_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  estimate_block_ = value;
}
inline void Reply_KV::set_estimate_block(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_estimate_block(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.KV.estimate_block)
}

// -------------------------------------------------------------------

// Reply_SQLLedgerAudit

// optional int64 block_no = 1;
inline bool Reply_SQLLedgerAudit::_internal_has_block_no() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reply_SQLLedgerAudit::has_block_no() const {
  return _internal_has_block_no();
}
inline void Reply_SQLLedgerAudit::clear_block_no() {
  block_no_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_SQLLedgerAudit::_internal_block_no() const {
  return block_no_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_SQLLedgerAudit::block_no() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.SQLLedgerAudit.block_no)
  return _internal_block_no();
}
inline void Reply_SQLLedgerAudit::_internal_set_block_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  block_no_ = value;
}
inline void Reply_SQLLedgerAudit::set_block_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_block_no(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.SQLLedgerAudit.block_no)
}

// optional bytes digest = 2;
inline bool Reply_SQLLedgerAudit::_internal_has_digest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reply_SQLLedgerAudit::has_digest() const {
  return _internal_has_digest();
}
inline void Reply_SQLLedgerAudit::clear_digest() {
  digest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reply_SQLLedgerAudit::digest() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.SQLLedgerAudit.digest)
  return _internal_digest();
}
inline void Reply_SQLLedgerAudit::set_digest(const std::string& value) {
  _internal_set_digest(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.SQLLedgerAudit.digest)
}
inline std::string* Reply_SQLLedgerAudit::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.SQLLedgerAudit.digest)
  return _internal_mutable_digest();
}
inline const std::string& Reply_SQLLedgerAudit::_internal_digest() const {
  return digest_.Get();
}
inline void Reply_SQLLedgerAudit::_internal_set_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_SQLLedgerAudit::set_digest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.SQLLedgerAudit.digest)
}
inline void Reply_SQLLedgerAudit::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.SQLLedgerAudit.digest)
}
inline void Reply_SQLLedgerAudit::set_digest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.SQLLedgerAudit.digest)
}
inline std::string* Reply_SQLLedgerAudit::_internal_mutable_digest() {
  _has_bits_[0] |= 0x00000001u;
  return digest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_SQLLedgerAudit::release_digest() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.SQLLedgerAudit.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_SQLLedgerAudit::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.SQLLedgerAudit.digest)
}

// optional bytes txns = 3;
inline bool Reply_SQLLedgerAudit::_internal_has_txns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reply_SQLLedgerAudit::has_txns() const {
  return _internal_has_txns();
}
inline void Reply_SQLLedgerAudit::clear_txns() {
  txns_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Reply_SQLLedgerAudit::txns() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.SQLLedgerAudit.txns)
  return _internal_txns();
}
inline void Reply_SQLLedgerAudit::set_txns(const std::string& value) {
  _internal_set_txns(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.SQLLedgerAudit.txns)
}
inline std::string* Reply_SQLLedgerAudit::mutable_txns() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.SQLLedgerAudit.txns)
  return _internal_mutable_txns();
}
inline const std::string& Reply_SQLLedgerAudit::_internal_txns() const {
  return txns_.Get();
}
inline void Reply_SQLLedgerAudit::_internal_set_txns(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  txns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_SQLLedgerAudit::set_txns(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  txns_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.SQLLedgerAudit.txns)
}
inline void Reply_SQLLedgerAudit::set_txns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  txns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.SQLLedgerAudit.txns)
}
inline void Reply_SQLLedgerAudit::set_txns(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  txns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.SQLLedgerAudit.txns)
}
inline std::string* Reply_SQLLedgerAudit::_internal_mutable_txns() {
  _has_bits_[0] |= 0x00000002u;
  return txns_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_SQLLedgerAudit::release_txns() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.SQLLedgerAudit.txns)
  if (!_internal_has_txns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return txns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_SQLLedgerAudit::set_allocated_txns(std::string* txns) {
  if (txns != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  txns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txns,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.SQLLedgerAudit.txns)
}

// repeated bytes blocks = 4;
inline int Reply_SQLLedgerAudit::_internal_blocks_size() const {
  return blocks_.size();
}
inline int Reply_SQLLedgerAudit::blocks_size() const {
  return _internal_blocks_size();
}
inline void Reply_SQLLedgerAudit::clear_blocks() {
  blocks_.Clear();
}
inline std::string* Reply_SQLLedgerAudit::add_blocks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  return _internal_add_blocks();
}
inline const std::string& Reply_SQLLedgerAudit::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const std::string& Reply_SQLLedgerAudit::blocks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  return _internal_blocks(index);
}
inline std::string* Reply_SQLLedgerAudit::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  return blocks_.Mutable(index);
}
inline void Reply_SQLLedgerAudit::set_blocks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  blocks_.Mutable(index)->assign(value);
}
inline void Reply_SQLLedgerAudit::set_blocks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  blocks_.Mutable(index)->assign(std::move(value));
}
inline void Reply_SQLLedgerAudit::set_blocks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline void Reply_SQLLedgerAudit::set_blocks(int index, const void* value, size_t size) {
  blocks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline std::string* Reply_SQLLedgerAudit::_internal_add_blocks() {
  return blocks_.Add();
}
inline void Reply_SQLLedgerAudit::add_blocks(const std::string& value) {
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline void Reply_SQLLedgerAudit::add_blocks(std::string&& value) {
  blocks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline void Reply_SQLLedgerAudit::add_blocks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline void Reply_SQLLedgerAudit::add_blocks(const void* value, size_t size) {
  blocks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.Reply.SQLLedgerAudit.blocks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Reply_SQLLedgerAudit::blocks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  return blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Reply_SQLLedgerAudit::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.SQLLedgerAudit.blocks)
  return &blocks_;
}

// -------------------------------------------------------------------

// Reply_LedgerDBAudit

// optional bytes digest = 1;
inline bool Reply_LedgerDBAudit::_internal_has_digest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reply_LedgerDBAudit::has_digest() const {
  return _internal_has_digest();
}
inline void Reply_LedgerDBAudit::clear_digest() {
  digest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reply_LedgerDBAudit::digest() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.digest)
  return _internal_digest();
}
inline void Reply_LedgerDBAudit::set_digest(const std::string& value) {
  _internal_set_digest(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.digest)
}
inline std::string* Reply_LedgerDBAudit::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.LedgerDBAudit.digest)
  return _internal_mutable_digest();
}
inline const std::string& Reply_LedgerDBAudit::_internal_digest() const {
  return digest_.Get();
}
inline void Reply_LedgerDBAudit::_internal_set_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply_LedgerDBAudit::set_digest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.LedgerDBAudit.digest)
}
inline void Reply_LedgerDBAudit::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.LedgerDBAudit.digest)
}
inline void Reply_LedgerDBAudit::set_digest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.LedgerDBAudit.digest)
}
inline std::string* Reply_LedgerDBAudit::_internal_mutable_digest() {
  _has_bits_[0] |= 0x00000001u;
  return digest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply_LedgerDBAudit::release_digest() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.LedgerDBAudit.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply_LedgerDBAudit::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.LedgerDBAudit.digest)
}

// optional int64 commit_seq = 2;
inline bool Reply_LedgerDBAudit::_internal_has_commit_seq() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reply_LedgerDBAudit::has_commit_seq() const {
  return _internal_has_commit_seq();
}
inline void Reply_LedgerDBAudit::clear_commit_seq() {
  commit_seq_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_LedgerDBAudit::_internal_commit_seq() const {
  return commit_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_LedgerDBAudit::commit_seq() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.commit_seq)
  return _internal_commit_seq();
}
inline void Reply_LedgerDBAudit::_internal_set_commit_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  commit_seq_ = value;
}
inline void Reply_LedgerDBAudit::set_commit_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_commit_seq(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.commit_seq)
}

// optional int64 first_block_seq = 3;
inline bool Reply_LedgerDBAudit::_internal_has_first_block_seq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reply_LedgerDBAudit::has_first_block_seq() const {
  return _internal_has_first_block_seq();
}
inline void Reply_LedgerDBAudit::clear_first_block_seq() {
  first_block_seq_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_LedgerDBAudit::_internal_first_block_seq() const {
  return first_block_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply_LedgerDBAudit::first_block_seq() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.first_block_seq)
  return _internal_first_block_seq();
}
inline void Reply_LedgerDBAudit::_internal_set_first_block_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  first_block_seq_ = value;
}
inline void Reply_LedgerDBAudit::set_first_block_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_first_block_seq(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.first_block_seq)
}

// repeated bytes commits = 4;
inline int Reply_LedgerDBAudit::_internal_commits_size() const {
  return commits_.size();
}
inline int Reply_LedgerDBAudit::commits_size() const {
  return _internal_commits_size();
}
inline void Reply_LedgerDBAudit::clear_commits() {
  commits_.Clear();
}
inline std::string* Reply_LedgerDBAudit::add_commits() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.Reply.LedgerDBAudit.commits)
  return _internal_add_commits();
}
inline const std::string& Reply_LedgerDBAudit::_internal_commits(int index) const {
  return commits_.Get(index);
}
inline const std::string& Reply_LedgerDBAudit::commits(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.commits)
  return _internal_commits(index);
}
inline std::string* Reply_LedgerDBAudit::mutable_commits(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.LedgerDBAudit.commits)
  return commits_.Mutable(index);
}
inline void Reply_LedgerDBAudit::set_commits(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.commits)
  commits_.Mutable(index)->assign(value);
}
inline void Reply_LedgerDBAudit::set_commits(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.commits)
  commits_.Mutable(index)->assign(std::move(value));
}
inline void Reply_LedgerDBAudit::set_commits(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  commits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline void Reply_LedgerDBAudit::set_commits(int index, const void* value, size_t size) {
  commits_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline std::string* Reply_LedgerDBAudit::_internal_add_commits() {
  return commits_.Add();
}
inline void Reply_LedgerDBAudit::add_commits(const std::string& value) {
  commits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline void Reply_LedgerDBAudit::add_commits(std::string&& value) {
  commits_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline void Reply_LedgerDBAudit::add_commits(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  commits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline void Reply_LedgerDBAudit::add_commits(const void* value, size_t size) {
  commits_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.Reply.LedgerDBAudit.commits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Reply_LedgerDBAudit::commits() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.LedgerDBAudit.commits)
  return commits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Reply_LedgerDBAudit::mutable_commits() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.LedgerDBAudit.commits)
  return &commits_;
}

// repeated bytes blocks = 5;
inline int Reply_LedgerDBAudit::_internal_blocks_size() const {
  return blocks_.size();
}
inline int Reply_LedgerDBAudit::blocks_size() const {
  return _internal_blocks_size();
}
inline void Reply_LedgerDBAudit::clear_blocks() {
  blocks_.Clear();
}
inline std::string* Reply_LedgerDBAudit::add_blocks() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.Reply.LedgerDBAudit.blocks)
  return _internal_add_blocks();
}
inline const std::string& Reply_LedgerDBAudit::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const std::string& Reply_LedgerDBAudit::blocks(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.blocks)
  return _internal_blocks(index);
}
inline std::string* Reply_LedgerDBAudit::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.LedgerDBAudit.blocks)
  return blocks_.Mutable(index);
}
inline void Reply_LedgerDBAudit::set_blocks(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.blocks)
  blocks_.Mutable(index)->assign(value);
}
inline void Reply_LedgerDBAudit::set_blocks(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.LedgerDBAudit.blocks)
  blocks_.Mutable(index)->assign(std::move(value));
}
inline void Reply_LedgerDBAudit::set_blocks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline void Reply_LedgerDBAudit::set_blocks(int index, const void* value, size_t size) {
  blocks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline std::string* Reply_LedgerDBAudit::_internal_add_blocks() {
  return blocks_.Add();
}
inline void Reply_LedgerDBAudit::add_blocks(const std::string& value) {
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline void Reply_LedgerDBAudit::add_blocks(std::string&& value) {
  blocks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline void Reply_LedgerDBAudit::add_blocks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blocks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline void Reply_LedgerDBAudit::add_blocks(const void* value, size_t size) {
  blocks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.Reply.LedgerDBAudit.blocks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Reply_LedgerDBAudit::blocks() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.LedgerDBAudit.blocks)
  return blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Reply_LedgerDBAudit::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.LedgerDBAudit.blocks)
  return &blocks_;
}

// repeated .strongstore.proto.MPTProof mptproofs = 6;
inline int Reply_LedgerDBAudit::_internal_mptproofs_size() const {
  return mptproofs_.size();
}
inline int Reply_LedgerDBAudit::mptproofs_size() const {
  return _internal_mptproofs_size();
}
inline void Reply_LedgerDBAudit::clear_mptproofs() {
  mptproofs_.Clear();
}
inline ::strongstore::proto::MPTProof* Reply_LedgerDBAudit::mutable_mptproofs(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.LedgerDBAudit.mptproofs)
  return mptproofs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::MPTProof >*
Reply_LedgerDBAudit::mutable_mptproofs() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.LedgerDBAudit.mptproofs)
  return &mptproofs_;
}
inline const ::strongstore::proto::MPTProof& Reply_LedgerDBAudit::_internal_mptproofs(int index) const {
  return mptproofs_.Get(index);
}
inline const ::strongstore::proto::MPTProof& Reply_LedgerDBAudit::mptproofs(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.LedgerDBAudit.mptproofs)
  return _internal_mptproofs(index);
}
inline ::strongstore::proto::MPTProof* Reply_LedgerDBAudit::_internal_add_mptproofs() {
  return mptproofs_.Add();
}
inline ::strongstore::proto::MPTProof* Reply_LedgerDBAudit::add_mptproofs() {
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.LedgerDBAudit.mptproofs)
  return _internal_add_mptproofs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::MPTProof >&
Reply_LedgerDBAudit::mptproofs() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.LedgerDBAudit.mptproofs)
  return mptproofs_;
}

// -------------------------------------------------------------------

// Reply

// required int32 status = 1;
inline bool Reply::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Reply::has_status() const {
  return _internal_has_status();
}
inline void Reply::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Reply::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Reply::status() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.status)
  return _internal_status();
}
inline void Reply::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  status_ = value;
}
inline void Reply::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.status)
}

// optional string value = 2;
inline bool Reply::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reply::has_value() const {
  return _internal_has_value();
}
inline void Reply::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reply::value() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.value)
  return _internal_value();
}
inline void Reply::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.value)
}
inline std::string* Reply::mutable_value() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.value)
  return _internal_mutable_value();
}
inline const std::string& Reply::_internal_value() const {
  return value_.Get();
}
inline void Reply::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reply::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:strongstore.proto.Reply.value)
}
inline void Reply::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.value)
}
inline void Reply::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.value)
}
inline std::string* Reply::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reply::release_value() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reply::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.value)
}

// optional int64 timestamp = 3;
inline bool Reply::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Reply::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Reply::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply::timestamp() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.timestamp)
  return _internal_timestamp();
}
inline void Reply::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = value;
}
inline void Reply::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.timestamp)
}

// optional .strongstore.proto.Reply.Digest digest = 4;
inline bool Reply::_internal_has_digest() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || digest_ != nullptr);
  return value;
}
inline bool Reply::has_digest() const {
  return _internal_has_digest();
}
inline void Reply::clear_digest() {
  if (digest_ != nullptr) digest_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::strongstore::proto::Reply_Digest& Reply::_internal_digest() const {
  const ::strongstore::proto::Reply_Digest* p = digest_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::Reply_Digest*>(
      &::strongstore::proto::_Reply_Digest_default_instance_);
}
inline const ::strongstore::proto::Reply_Digest& Reply::digest() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.digest)
  return _internal_digest();
}
inline void Reply::unsafe_arena_set_allocated_digest(
    ::strongstore::proto::Reply_Digest* digest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(digest_);
  }
  digest_ = digest;
  if (digest) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Reply.digest)
}
inline ::strongstore::proto::Reply_Digest* Reply::release_digest() {
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::Reply_Digest* temp = digest_;
  digest_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::Reply_Digest* Reply::unsafe_arena_release_digest() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.digest)
  _has_bits_[0] &= ~0x00000002u;
  ::strongstore::proto::Reply_Digest* temp = digest_;
  digest_ = nullptr;
  return temp;
}
inline ::strongstore::proto::Reply_Digest* Reply::_internal_mutable_digest() {
  _has_bits_[0] |= 0x00000002u;
  if (digest_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::Reply_Digest>(GetArena());
    digest_ = p;
  }
  return digest_;
}
inline ::strongstore::proto::Reply_Digest* Reply::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.digest)
  return _internal_mutable_digest();
}
inline void Reply::set_allocated_digest(::strongstore::proto::Reply_Digest* digest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete digest_;
  }
  if (digest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(digest);
    if (message_arena != submessage_arena) {
      digest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, digest, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  digest_ = digest;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.digest)
}

// repeated .strongstore.proto.Reply.KV values = 5;
inline int Reply::_internal_values_size() const {
  return values_.size();
}
inline int Reply::values_size() const {
  return _internal_values_size();
}
inline void Reply::clear_values() {
  values_.Clear();
}
inline ::strongstore::proto::Reply_KV* Reply::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Reply_KV >*
Reply::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.values)
  return &values_;
}
inline const ::strongstore::proto::Reply_KV& Reply::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::strongstore::proto::Reply_KV& Reply::values(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.values)
  return _internal_values(index);
}
inline ::strongstore::proto::Reply_KV* Reply::_internal_add_values() {
  return values_.Add();
}
inline ::strongstore::proto::Reply_KV* Reply::add_values() {
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.values)
  return _internal_add_values();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::Reply_KV >&
Reply::values() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.values)
  return values_;
}

// repeated int64 timestamps = 6;
inline int Reply::_internal_timestamps_size() const {
  return timestamps_.size();
}
inline int Reply::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void Reply::clear_timestamps() {
  timestamps_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply::_internal_timestamps(int index) const {
  return timestamps_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Reply::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.timestamps)
  return _internal_timestamps(index);
}
inline void Reply::set_timestamps(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.timestamps)
}
inline void Reply::_internal_add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  timestamps_.Add(value);
}
inline void Reply::add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_timestamps(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.timestamps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
Reply::_internal_timestamps() const {
  return timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
Reply::timestamps() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.timestamps)
  return _internal_timestamps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
Reply::_internal_mutable_timestamps() {
  return &timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
Reply::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.timestamps)
  return _internal_mutable_timestamps();
}

// optional .strongstore.proto.USTOREProof uproof = 7;
inline bool Reply::_internal_has_uproof() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || uproof_ != nullptr);
  return value;
}
inline bool Reply::has_uproof() const {
  return _internal_has_uproof();
}
inline void Reply::clear_uproof() {
  if (uproof_ != nullptr) uproof_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::strongstore::proto::USTOREProof& Reply::_internal_uproof() const {
  const ::strongstore::proto::USTOREProof* p = uproof_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::USTOREProof*>(
      &::strongstore::proto::_USTOREProof_default_instance_);
}
inline const ::strongstore::proto::USTOREProof& Reply::uproof() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.uproof)
  return _internal_uproof();
}
inline void Reply::unsafe_arena_set_allocated_uproof(
    ::strongstore::proto::USTOREProof* uproof) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uproof_);
  }
  uproof_ = uproof;
  if (uproof) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Reply.uproof)
}
inline ::strongstore::proto::USTOREProof* Reply::release_uproof() {
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::USTOREProof* temp = uproof_;
  uproof_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::USTOREProof* Reply::unsafe_arena_release_uproof() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.uproof)
  _has_bits_[0] &= ~0x00000004u;
  ::strongstore::proto::USTOREProof* temp = uproof_;
  uproof_ = nullptr;
  return temp;
}
inline ::strongstore::proto::USTOREProof* Reply::_internal_mutable_uproof() {
  _has_bits_[0] |= 0x00000004u;
  if (uproof_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::USTOREProof>(GetArena());
    uproof_ = p;
  }
  return uproof_;
}
inline ::strongstore::proto::USTOREProof* Reply::mutable_uproof() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.uproof)
  return _internal_mutable_uproof();
}
inline void Reply::set_allocated_uproof(::strongstore::proto::USTOREProof* uproof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete uproof_;
  }
  if (uproof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(uproof);
    if (message_arena != submessage_arena) {
      uproof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uproof, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  uproof_ = uproof;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.uproof)
}

// repeated .strongstore.proto.QLDBProof qproof = 8;
inline int Reply::_internal_qproof_size() const {
  return qproof_.size();
}
inline int Reply::qproof_size() const {
  return _internal_qproof_size();
}
inline void Reply::clear_qproof() {
  qproof_.Clear();
}
inline ::strongstore::proto::QLDBProof* Reply::mutable_qproof(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.qproof)
  return qproof_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::QLDBProof >*
Reply::mutable_qproof() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.qproof)
  return &qproof_;
}
inline const ::strongstore::proto::QLDBProof& Reply::_internal_qproof(int index) const {
  return qproof_.Get(index);
}
inline const ::strongstore::proto::QLDBProof& Reply::qproof(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.qproof)
  return _internal_qproof(index);
}
inline ::strongstore::proto::QLDBProof* Reply::_internal_add_qproof() {
  return qproof_.Add();
}
inline ::strongstore::proto::QLDBProof* Reply::add_qproof() {
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.qproof)
  return _internal_add_qproof();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::QLDBProof >&
Reply::qproof() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.qproof)
  return qproof_;
}

// repeated .strongstore.proto.LedgerDBProof proof = 9;
inline int Reply::_internal_proof_size() const {
  return proof_.size();
}
inline int Reply::proof_size() const {
  return _internal_proof_size();
}
inline void Reply::clear_proof() {
  proof_.Clear();
}
inline ::strongstore::proto::LedgerDBProof* Reply::mutable_proof(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.proof)
  return proof_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::LedgerDBProof >*
Reply::mutable_proof() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.proof)
  return &proof_;
}
inline const ::strongstore::proto::LedgerDBProof& Reply::_internal_proof(int index) const {
  return proof_.Get(index);
}
inline const ::strongstore::proto::LedgerDBProof& Reply::proof(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.proof)
  return _internal_proof(index);
}
inline ::strongstore::proto::LedgerDBProof* Reply::_internal_add_proof() {
  return proof_.Add();
}
inline ::strongstore::proto::LedgerDBProof* Reply::add_proof() {
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.proof)
  return _internal_add_proof();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::LedgerDBProof >&
Reply::proof() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.proof)
  return proof_;
}

// repeated bytes blockdata = 10;
inline int Reply::_internal_blockdata_size() const {
  return blockdata_.size();
}
inline int Reply::blockdata_size() const {
  return _internal_blockdata_size();
}
inline void Reply::clear_blockdata() {
  blockdata_.Clear();
}
inline std::string* Reply::add_blockdata() {
  // @@protoc_insertion_point(field_add_mutable:strongstore.proto.Reply.blockdata)
  return _internal_add_blockdata();
}
inline const std::string& Reply::_internal_blockdata(int index) const {
  return blockdata_.Get(index);
}
inline const std::string& Reply::blockdata(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.blockdata)
  return _internal_blockdata(index);
}
inline std::string* Reply::mutable_blockdata(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.blockdata)
  return blockdata_.Mutable(index);
}
inline void Reply::set_blockdata(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.blockdata)
  blockdata_.Mutable(index)->assign(value);
}
inline void Reply::set_blockdata(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:strongstore.proto.Reply.blockdata)
  blockdata_.Mutable(index)->assign(std::move(value));
}
inline void Reply::set_blockdata(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blockdata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strongstore.proto.Reply.blockdata)
}
inline void Reply::set_blockdata(int index, const void* value, size_t size) {
  blockdata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strongstore.proto.Reply.blockdata)
}
inline std::string* Reply::_internal_add_blockdata() {
  return blockdata_.Add();
}
inline void Reply::add_blockdata(const std::string& value) {
  blockdata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.blockdata)
}
inline void Reply::add_blockdata(std::string&& value) {
  blockdata_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.blockdata)
}
inline void Reply::add_blockdata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blockdata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strongstore.proto.Reply.blockdata)
}
inline void Reply::add_blockdata(const void* value, size_t size) {
  blockdata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strongstore.proto.Reply.blockdata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Reply::blockdata() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.blockdata)
  return blockdata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Reply::mutable_blockdata() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.blockdata)
  return &blockdata_;
}

// repeated .strongstore.proto.SQLLedgerProof sproof = 11;
inline int Reply::_internal_sproof_size() const {
  return sproof_.size();
}
inline int Reply::sproof_size() const {
  return _internal_sproof_size();
}
inline void Reply::clear_sproof() {
  sproof_.Clear();
}
inline ::strongstore::proto::SQLLedgerProof* Reply::mutable_sproof(int index) {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.sproof)
  return sproof_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::SQLLedgerProof >*
Reply::mutable_sproof() {
  // @@protoc_insertion_point(field_mutable_list:strongstore.proto.Reply.sproof)
  return &sproof_;
}
inline const ::strongstore::proto::SQLLedgerProof& Reply::_internal_sproof(int index) const {
  return sproof_.Get(index);
}
inline const ::strongstore::proto::SQLLedgerProof& Reply::sproof(int index) const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.sproof)
  return _internal_sproof(index);
}
inline ::strongstore::proto::SQLLedgerProof* Reply::_internal_add_sproof() {
  return sproof_.Add();
}
inline ::strongstore::proto::SQLLedgerProof* Reply::add_sproof() {
  // @@protoc_insertion_point(field_add:strongstore.proto.Reply.sproof)
  return _internal_add_sproof();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::strongstore::proto::SQLLedgerProof >&
Reply::sproof() const {
  // @@protoc_insertion_point(field_list:strongstore.proto.Reply.sproof)
  return sproof_;
}

// optional .strongstore.proto.Reply.SQLLedgerAudit saudit = 12;
inline bool Reply::_internal_has_saudit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || saudit_ != nullptr);
  return value;
}
inline bool Reply::has_saudit() const {
  return _internal_has_saudit();
}
inline void Reply::clear_saudit() {
  if (saudit_ != nullptr) saudit_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::strongstore::proto::Reply_SQLLedgerAudit& Reply::_internal_saudit() const {
  const ::strongstore::proto::Reply_SQLLedgerAudit* p = saudit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::Reply_SQLLedgerAudit*>(
      &::strongstore::proto::_Reply_SQLLedgerAudit_default_instance_);
}
inline const ::strongstore::proto::Reply_SQLLedgerAudit& Reply::saudit() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.saudit)
  return _internal_saudit();
}
inline void Reply::unsafe_arena_set_allocated_saudit(
    ::strongstore::proto::Reply_SQLLedgerAudit* saudit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(saudit_);
  }
  saudit_ = saudit;
  if (saudit) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Reply.saudit)
}
inline ::strongstore::proto::Reply_SQLLedgerAudit* Reply::release_saudit() {
  _has_bits_[0] &= ~0x00000008u;
  ::strongstore::proto::Reply_SQLLedgerAudit* temp = saudit_;
  saudit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::Reply_SQLLedgerAudit* Reply::unsafe_arena_release_saudit() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.saudit)
  _has_bits_[0] &= ~0x00000008u;
  ::strongstore::proto::Reply_SQLLedgerAudit* temp = saudit_;
  saudit_ = nullptr;
  return temp;
}
inline ::strongstore::proto::Reply_SQLLedgerAudit* Reply::_internal_mutable_saudit() {
  _has_bits_[0] |= 0x00000008u;
  if (saudit_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::Reply_SQLLedgerAudit>(GetArena());
    saudit_ = p;
  }
  return saudit_;
}
inline ::strongstore::proto::Reply_SQLLedgerAudit* Reply::mutable_saudit() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.saudit)
  return _internal_mutable_saudit();
}
inline void Reply::set_allocated_saudit(::strongstore::proto::Reply_SQLLedgerAudit* saudit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete saudit_;
  }
  if (saudit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(saudit);
    if (message_arena != submessage_arena) {
      saudit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saudit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  saudit_ = saudit;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.saudit)
}

// optional .strongstore.proto.Reply.LedgerDBAudit laudit = 13;
inline bool Reply::_internal_has_laudit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || laudit_ != nullptr);
  return value;
}
inline bool Reply::has_laudit() const {
  return _internal_has_laudit();
}
inline void Reply::clear_laudit() {
  if (laudit_ != nullptr) laudit_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::strongstore::proto::Reply_LedgerDBAudit& Reply::_internal_laudit() const {
  const ::strongstore::proto::Reply_LedgerDBAudit* p = laudit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::strongstore::proto::Reply_LedgerDBAudit*>(
      &::strongstore::proto::_Reply_LedgerDBAudit_default_instance_);
}
inline const ::strongstore::proto::Reply_LedgerDBAudit& Reply::laudit() const {
  // @@protoc_insertion_point(field_get:strongstore.proto.Reply.laudit)
  return _internal_laudit();
}
inline void Reply::unsafe_arena_set_allocated_laudit(
    ::strongstore::proto::Reply_LedgerDBAudit* laudit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(laudit_);
  }
  laudit_ = laudit;
  if (laudit) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strongstore.proto.Reply.laudit)
}
inline ::strongstore::proto::Reply_LedgerDBAudit* Reply::release_laudit() {
  _has_bits_[0] &= ~0x00000010u;
  ::strongstore::proto::Reply_LedgerDBAudit* temp = laudit_;
  laudit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::strongstore::proto::Reply_LedgerDBAudit* Reply::unsafe_arena_release_laudit() {
  // @@protoc_insertion_point(field_release:strongstore.proto.Reply.laudit)
  _has_bits_[0] &= ~0x00000010u;
  ::strongstore::proto::Reply_LedgerDBAudit* temp = laudit_;
  laudit_ = nullptr;
  return temp;
}
inline ::strongstore::proto::Reply_LedgerDBAudit* Reply::_internal_mutable_laudit() {
  _has_bits_[0] |= 0x00000010u;
  if (laudit_ == nullptr) {
    auto* p = CreateMaybeMessage<::strongstore::proto::Reply_LedgerDBAudit>(GetArena());
    laudit_ = p;
  }
  return laudit_;
}
inline ::strongstore::proto::Reply_LedgerDBAudit* Reply::mutable_laudit() {
  // @@protoc_insertion_point(field_mutable:strongstore.proto.Reply.laudit)
  return _internal_mutable_laudit();
}
inline void Reply::set_allocated_laudit(::strongstore::proto::Reply_LedgerDBAudit* laudit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete laudit_;
  }
  if (laudit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(laudit);
    if (message_arena != submessage_arena) {
      laudit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laudit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  laudit_ = laudit;
  // @@protoc_insertion_point(field_set_allocated:strongstore.proto.Reply.laudit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace strongstore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::strongstore::proto::Request_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strongstore::proto::Request_Operation>() {
  return ::strongstore::proto::Request_Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_strong_2dproto_2eproto
